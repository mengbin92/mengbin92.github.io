---
layout: post
title: 设计模式之适配器模式
tags: 设计模式
mermaid: false
math: false
--- 

## 基本概念

适配器模式（Adapter Pattern）是一种结构型设计模式，它允许将现有类（即被适配者）的接口转换成另一种接口，以满足客户端的期望。适配器模式通常用作两种不兼容接口之间的桥梁，使得原本由于接口不兼容而不能一起工作的类可以一起工作。

在适配器模式中，我们定义一个适配器类，它实现了目标接口，并持有一个被适配者的实例。适配器类将被适配者的方法调用委派给被适配者实例，从而实现目标接口。客户端代码只需要依赖于目标接口，而不需要关心具体的被适配者实现。这样，即使被适配者的接口发生变化，客户端代码也不需要修改，提高了系统的灵活性和可扩展性。

适配器模式主要涉及以下几个角色：

- **目标接口（Target）**： 定义客户端使用的特定接口，客户端通过该接口与适配器进行交互。
- **适配器（Adapter）**： 实现目标接口，并包装一个需要适配的类的对象。适配器将客户端的请求转换为对被适配者的调用。
- **被适配者（Adaptee）**： 需要被适配的类，其接口与目标接口不兼容。
- **客户端（Client）**： 使用目标接口与适配器进行交互，以访问被适配者的功能。  

下面是适配器模式的一般结构：  

```mermaid
classDiagram
    class TargetInterface {
        +method1()
        +method2()
    }
    class Adaptee {
        +specificMethod1()
        +specificMethod2()
    }
    class Adapter {
        +method1()
        +method2()
        +specificMethod1()
        +specificMethod2()
    }
    TargetInterface <|-- Adapter
    Adaptee <|-- Adapter
```  

## 适配器模式分类

适配器模式可以分为以下三种分类：

1. 类适配器（Class Adapter）：类适配器使用继承来实现适配器接口。在这种适配器模式中，适配器类继承自被适配者类，并实现目标接口。这种方式要求被适配者类必须有可供继承的类定义。
2. 对象适配器（Object Adapter）：对象适配器使用组合来实现适配器接口。在这种适配器模式中，适配器类包含一个被适配者类的实例，并通过持有被适配者实例的方式实现目标接口。这种方式不要求被适配者类必须有可供继承的类定义。
3. 双向适配器（Two-way Adapter）：双向适配器结合了类适配器和对象适配器的特性，既继承自被适配者类，也包含一个被适配者类的实例。这种方式适用于需要同时适配多个不兼容接口的场合。

在实际应用中，可以根据具体的场景和需求选择合适的适配器模式。通常情况下，如果被适配者类已经有了可供继承的类定义，那么可以选择类适配器；如果被适配者类没有可供继承的类定义，那么可以选择对象适配器；如果需要同时适配多个不兼容接口，那么可以选择双向适配器。  

## 适配器模式的适用场景

适配器模式是一种结构性设计模式，用于解决接口不兼容的问题。当现有的类无法直接满足系统的需求或与其他类协同工作时，适配器模式提供了一种灵活的解决方案。适配器模式的使用场景包括：

1. **接口不兼容**：当需要使用一个已经存在的类，但其接口不符合你的需求时，可以使用适配器模式。通过创建一个适配器，可以将该类的接口转换成客户期望的另一个接口。
2. **复用类**：当想要创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作时，可以使用适配器模式。适配器可以使这些不相关的类能够协同工作，提高代码的可维护性和可扩展性。
3. **子类化问题**：当需要使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口时，可以使用适配器模式。通过创建一个适配器，可以将这些子类的接口转换成统一的接口，从而简化代码实现。
4. **代码解耦**：适配器模式有助于降低代码之间的耦合度。通过使用适配器，可以将实现细节与客户端代码分离，使得代码更容易维护和扩展。
5. **框架与库的兼容性**：当使用第三方框架或库时，可能会遇到接口不兼容的问题。适配器模式可以帮助解决这种问题，使你的代码能够与第三方框架或库更好地协同工作。

总之，适配器模式适用于需要解决接口不兼容、实现代码复用、降低代码耦合度以及解决框架与库兼容性问题的情况。

## 适配器模式的优缺点

适配器模式是一种结构型设计模式，它的主要目的是将一个接口转换成客户期望的另一个接口，使得原本由于接口不兼容而无法一起工作的类能够协同工作。适配器模式有以下优缺点：

优点：
1. 兼容性：适配器模式能够使不兼容的接口协同工作，提供了一种兼容性解决方案。
2. 重用性：通过适配器，可以重用已有的类，而无需修改源代码。
3. 灵活性：适配器模式可以在不影响现有代码的情况下引入新的类，从而增加系统的灵活性。
4. 解耦性：适配器模式将客户端与目标类解耦，客户端只需要面向适配器编程，无需直接与目标类交互。
5. 扩展性：当需要添加新的适配者类时，只需创建一个新的适配器类，对已有代码的影响较小。

缺点：
1. 过多使用适配器可能导致系统复杂性和混乱度增加，使得系统难以理解和维护。
2. 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。
3. 增加代码阅读难度和降低代码可读性，因为适配器可能隐藏了实际执行的操作。
4. 如果过度依赖适配器，可能会忽视对原有系统或接口进行改进的机会。
5. 对于简单的适配情况，使用适配器模式可能过于复杂，不如直接修改源代码来得直接和简单。

在实际应用中，适配器模式的优点使其在处理接口不兼容、需要复用现有类或者希望提高系统灵活性和扩展性的情况下非常有用。然而，也需要注意其潜在的缺点，避免过度使用或不当使用导致的系统复杂性和维护困难。在设计系统时，应根据具体需求和权衡利弊来决定是否使用适配器模式。  

## 示例

以下是一个简单的类适配器模式的Go语言示例：

```go
package main

import "fmt"

// Target 接口定义需要适配的目标接口
type Target interface {
	Request() string
}

// Adaptee 是一个已经存在的类，无法直接修改其代码
type Adaptee struct{}

func (a *Adaptee) SpecificRequest() string {
	return "Adaptee specific request"
}

// Adapter 是一个适配器类，将 Adaptee 转换为 Target 接口
type Adapter struct {
	adaptee *Adaptee
}

func (ada *Adapter) Request() string {
	return ada.adaptee.SpecificRequest()
}

func main() {
	// 创建一个 Adaptee 对象
	adaptee := &Adaptee{}

	// 创建一个适配器对象，将 Adaptee 对象传递给适配器
	adapter := &Adapter{
		adaptee: adaptee,
	}

	// 通过适配器调用目标方法
	result := adapter.Request()

	fmt.Println("Result:", result)
}
```

---

<div align="center">
  <img src="../img/qrcode_wechat.jpg" alt="孟斯特">
</div>

> 声明：本作品采用[署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)进行许可，使用时请注明出处。  
> Author: [mengbin](mengbin1992@outlook.com)  
> blog: [mengbin](https://mengbin.top)  
> Github: [mengbin92](https://mengbin92.github.io/)  
> cnblogs: [恋水无意](https://www.cnblogs.com/lianshuiwuyi/)  
> 腾讯云开发者社区：[孟斯特](https://cloud.tencent.com/developer/user/6649301)  

---
