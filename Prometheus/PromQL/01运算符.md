# 运算符

---

## 二元运算符

Prometheus的查询语句支持逻辑运算和四则运算。两个即时向量运算时，可以修改[匹配行为](#向量匹配)。

### 四则运算

在Prometheus中，存在以下四则运算符：

* +（加）
* -（减）
* *（乘）
* /（除）
* %（取模）
* ^（幂运算）

二元四则运算是在标量/标量、向量/标量和向量/向量之间使用。

**两个标量之间**，行为是明显的:它们计算到另一个标量，该标量是应用于两个标量操作数的操作符的结果。

**即时向量与标量之间**，该运算符应用于向量中每个数据样本的值。例如，如果一个时间序列瞬时向量乘以2，则结果是另一个向量，其中原始向量的每个样本值都乘以2。指标名称将被删除。

**两个向量之间**，将二元算术运算符应用于左边向量中的每一项及其右边向量中的匹配元素。结果被传播到结果向量中，分组标签成为输出标签集。指标名称将被删除。在右边向量中找不到匹配条目的条目不属于结果的一部分。

### 比较运算

在Prometheus中，存在以下比较运算：

* ==（等于）
* !=（不等于）
* \>（大于）
* <（小于）
* \>=（大于等于）
* <=（小于等于）

比较运算符定义在标量/标量、向量/标量和向量/向量值对之间。默认情况下，它们进行过滤。它们的行为可以通过在操作符后提供`bool`来修改，这将返回值`0`或`1`，而不是过滤。

**两个标量之间**，必须提供`bool`修饰符，这些操作符会导致另一个标量，根据比较结果，标量为`0(false)`或`1(true)`。

**即时向量与标量之间**，这些操作符应用于向量中的每个数据样本的值，并且将比较结果为`false`的向量元素从结果向量中删除。如果提供了`bool`修饰符，则要删除的向量元素的值为`0`，而要保留的向量元素的值为`1`。如果提供了`bool`修饰符，则删除指标名称。

**两个向量之间**，这些操作符在默认情况下作为过滤器，应用于匹配的条目。表达式不为真或在表达式的另一端没有找到匹配的向量元素将从结果中删除，而其他元素将传播到结果向量中，分组标签将成为输出标签集。如果提供了`bool`修饰符，那么将被删除的向量元素的值为`0`，而将被保留的向量元素的值为`1`，分组标签再次成为输出标签集。如果提供了`bool`修饰符，则删除指标名称。

### 逻辑/集合运算

逻辑/集合运算只能用于两个即时向量之间：

* and（且）
* or（或）
* unless（并集）

`vector1 and vector2`的结果是一个由`vector1`中的元素组成的向量，而`vector2`中的元素具有完全匹配的标签集。其他元素被删除。指标名称和值是从左边的向量传递过来的。

`vector1 or vector2`的结果是包含`vector1`的所有原始元素(标签集+值)和`vector2`中没有匹配标签集的所有元素的vector。

`vector1 unless vector2`的结果是由`vector1`的元素组成的向量，而在`vector2`中没有完全匹配的标签集。删除两个向量中所有匹配的元素。

---

## 向量匹配

两个向量之间的运算是为左边的每个元素在右边的向量中找到匹配的元素。匹配行为有两种基本类型:一对一和多对一/一对多。

### 一对一向量匹配

**一对一**从操作的每一边找到一对唯一的条目。在默认情况下，这是格式`vector1 <operation> vector2`。如果两个条目具有完全相同的标签集和相应的值，则它们是匹配的。忽略关键字允许在匹配时忽略某些标签，而on关键字允许将考虑的标签集减少到提供的列表：

> \<vector expr> \<bin-op> ignoring(\<label list>) \<vector expr>
> \<vector expr> \<bin-op> on(\<label list>) \<vector expr>

输入示例：

```
method_code:http_errors:rate5m{method="get", code="500"}  24
method_code:http_errors:rate5m{method="get", code="404"}  30
method_code:http_errors:rate5m{method="put", code="501"}  3
method_code:http_errors:rate5m{method="post", code="500"} 6
method_code:http_errors:rate5m{method="post", code="404"} 21

method:http_requests:rate5m{method="get"}  600
method:http_requests:rate5m{method="del"}  34
method:http_requests:rate5m{method="post"} 120
```

查询：

> method_code:http_errors:rate5m{code="500"} / ignoring(code) method:http_requests:rate5m

这将返回一个结果向量，其中包含每个方法的状态码为500的HTTP请求的部分，这是在过去5分钟内度量的结果。如果`ignoring(code)`，就不会有匹配，因为指标不共享相同的标签集。带有`put`和`del`方法的条目没有匹配，不会显示在结果中：

```
{method="get"}  0.04            //  24 / 600
{method="post"} 0.05            //   6 / 120
```

### 多对一和一对多匹配

**多对一**和**一对多**匹配是指“一”上的每个向量元素都可以与“多”上的多个元素匹配。这必须使用`group_left`或`group_right`修饰符显式请求，其中左/右决定哪个向量具有更高的基数。

```
<vector expr> <bin-op> ignoring(<label list>) group_left(<label list>) <vector expr>
<vector expr> <bin-op> ignoring(<label list>) group_right(<label list>) <vector expr>
<vector expr> <bin-op> on(<label list>) group_left(<label list>) <vector expr>
<vector expr> <bin-op> on(<label list>) group_right(<label list>) <vector expr>
```

与组修饰符一起提供的标签列表包含来自“一侧”的额外标签，这些标签将被包含在结果度量中。`on`只能出现在其中一个列表中。结果向量的每个时间序列必须是唯一可识别的。

_分组修饰符只能用于[比较](#比较运算)和[算术](#四则运算)。默认情况下，`and`、`unless`和`or`操作与右向量中所有可能的条目匹配。_

查询示例：

> method_code:http_errors:rate5m / ignoring(code) group_left method:http_requests:rate5m

在本例中，左向量每个`method`标签值包含多个条目。因此，我们使用`group_left`表示。右边的元素现在与左边的相同方法标签的多个元素相匹配：

```
{method="get", code="500"}  0.04            //  24 / 600
{method="get", code="404"}  0.05            //  30 / 600
{method="post", code="500"} 0.05            //   6 / 120
{method="post", code="404"} 0.175           //  21 / 120
```

_多对一和一对多匹配是应该仔细考虑的高级用法。通常，正确地使用`ignoring(<labels>)`会得到想要的结果。_

---

## 聚合操作

Prometheus支持以下内置聚合操作符，这些操作符可用于聚合单个瞬时向量的元素，从而生成一个包含更少元素、具有聚合值的新向量：

* sum
* min
* max
* avg
* group
* stddev
* stdvar
* count
* count_values
* bottomk
* topk
* quantile

这些操作符既可以用于对**所有**标签维度进行聚合，也可以通过包含`without`或`by`子句来保留不同的维度。这些子句可以用在该短语的前面或后面。

```
<aggr-op> [without|by (<label list>)] ([parameter,] <vector expression>)
```

或

```
<aggr-op>([parameter,] <vector expression>) [without|by (<label list>)]
```

`label list`是一个未加引号的标签列表，后面可能包含一个逗号，即`(label1, label2)`和`(label1, label2)`都是有效的语法。

`without`冲结果向量中删除列出的标签，其它所有标签正常输出。`by`则相反，会删除`by`字句中没有的标签，即使它们的标签值在vector的所有元素中是相同的。

`parameter`仅用于`count_values`，`quantile`，`topk`和`bottomk`。

`count_values`为每个唯一的样本值输出一个时间序列。每个系列都有一个附加标签。该标签的名称由聚合参数给出，标签值是唯一的样本值。每个时间序列的值是该样本值出现的次数。

`topk`和`bottomk`与其他聚合器不同的是，在结果向量中返回输入样本的子集(包括原始标签)。`by`和`without`仅用于抽取输入向量。

`quantile`计算φ-分位数，即在所有维度的N个度量值中排名为φ*N的值。以φ为聚合参数。例如，`quantile(0.5，…)`计算中位数，`quantile(0.95，…)`第95个百分位。

例如：

如果度量`http_requests_total`有按`application`、`instance`和`group`标签展开的时间序列，我们可以通过以下方法计算每个应用程序和组在所有实例上看到的HTTP请求的总数：

> sum without (instance) (http_requests_total)

等价于：

>  sum by (application, group) (http_requests_total)

如果我们只是对我们在所有应用程序中看到的HTTP请求的总数感兴趣，我们可以简单地写：

> sum(http_requests_total)

要计算运行每个构建版本的二进制文件的数量，我们可以这样写：

> count_values("version", build_version)

要获得所有实例中最大的5个HTTP请求，我们可以这样写：

> topk(5, http_requests_total)

---

## 运算符优先级

下面的列表显示了Prometheus中二元运算符的优先级，从高到低：

1. `^`
2. `\*` `/` `%`
3. `+` `-`
4. `==` `!=` `<=` `<` `>=` `>`
5. `and` `unless`
6. `or`

相同优先级的操作符是左关联的。例如，`2 * 3 % 2`相当于`(2 * 3)% 2`。但是`^`是右结合律，所以`2 ^ 3 ^ 2`等于`2 ^ (3 ^ 2)`。

---

> 声明：本作品采用[署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)进行许可，使用时请注明出处。
> Author: mengbin92
> Github: [mengbin92](https://mengbin92.github.io/)
> cnblogs: [恋水无意](https://www.cnblogs.com/lianshuiwuyi/)

---
