# Prometheus检索

原文来自[这里](https://prometheus.io/docs/prometheus/latest/querying/basics/)。

Prometheus提供了一个名为**PromQL**的函数式查询语言，它可以让用户实时选择和聚合时序数据。表达式的结果既可以展示为图形，也可以在Prometheus表达式浏览器中以数据列表形式展示，还可以通过[HTTP API](./HTTP%20API.md)供外部使用。

---

## 示例

本文档仅供参考。从一系列[示例](./示例.md)开始学习，更方便入门。

---

## 表达式语言数据类型

在Prometheus的表达式语言中，表达式或子式可以被计算为以下四种类型之一：

* **即时向量** 一组时间序列，每个时间序列包含一个样本，所有时间序列都共享相同的时间戳
* **范围向量** 一组时间序列，包含每个时间序列随时间变化的数据点范围
* **标量** 浮点型数字变量
* **字符串** 字符串变量，暂未使用

根据不同的使用场景（比如，将表达式的输出以图形展示时），在用户自定义的表达式的结果中只有部分类型是合法的。譬如，返回结果为即时向量的表达式才能直接作为图形化的类型。

---

## 字面量

### 字符串字面量

字符串是一组由单引号（'）、双引号（"）或者反引号（`）包括的字面量。

PromQL遵循着与Go相同的[转义规则](https://golang.org/ref/spec#String_literals)。在单双引号中，反斜线（\）开始转义一个字符，这个字符可以是其后跟着的`a`，`b`，`f`，`n`或者`\`。通过转义可以使用八进制（`\nnn`）或十六进制（`\xnn`、`\unnnn`和`\Unnnnnnnn`）。

反引号(`)内不处理转义。与Go不同，Prometheus不会丢失反引号内的换行符。

例如：

```
"this is a string"
'these are unescaped: \n \\ \t'
`these are not unescaped: \n ' " \t`
```

### 浮点型字面量

标量浮点值可以按以下格式写成文字整数或浮点数（仅包含空格以提高可读性）：

```
[-+]?(
      [0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?
    | 0[xX][0-9a-fA-F]+
    | [nN][aA][nN]
    | [iI][nN][fF]
)
```

例如：

```
23
-2.43
3.4e-9
0x8f
-Inf
NaN
```

---

## 时序选择器

### 即时向量选择器

即时向量选择器允许在给定的时间戳（即时）选择一组时间序列和单个样本值：在最简单的形式中，只指定一个度量名称。这会产生一个包含所有具有此度量名称的时间序列元素的即时向量。

此示例选择具有`http_requests_total`指标名称的所有时间序列：

> http_requests_total

可以通过在花括号 (`{}`) 中附加逗号分隔的标签匹配器列表来进一步过滤这些时间序列。

此示例仅选择具有`http_requests_total`度量名称且job标签设置为`prometheus`且`group`标签设置为`canary`的时间序列：

> http_requests_total{job="prometheus",group="canary"}

也可以否定匹配标签值，或将标签值与正则表达式匹配。存在以下标签匹配运算符：

* `=`：选择与提供的字符串完全相同的标签。
* `!=`：选择不等于提供的字符串的标签。
* `=~`：选择与提供的字符串正则表达式匹配的标签。
* `!~`：选择与提供的字符串不匹配的标签。

下面的示例将检索环境变量为`staging`、`testing`和`development`且HTTP方法不为`GET`的所有时序：

> http_requests_total{environment=~"staging|testing|development",method!="GET"}

匹配空标签值的标签匹配器还会选择没有设置特定标签的所有时间序列。正则表达式匹配是完全锚定的。同一个标签可以有多个匹配器。

向量选择器必须指定一个名称或至少一个与空字符串不匹配的标签匹配器。以下表达式是非法的：

> {job=~".*"} # Bad!

下面的表达式都是合法的，因为它们都包含一个不匹配空标签的选择器：

> {job=~".+"}              # Good!
> {job=~".*",method="get"} # Good!

标签匹配器也可用于匹配内置的`__name__`标签。例如，表达式`http_requests_total`等价于`{__name__="http_requests_total"}`。比较运算符`=`（`!= =~ !~`）也都可以使用。下面的表达式匹配所有以`job:`开头的标签：

> {\_\_name\_\_=~"job:.*"}

标签名称不能是关键字（`bool on ignoring group_left group_right`）。下面的例子是非法的：

> on{} # Bad!

此时就可以使用`__name__`标签：

> {\_\_name\_\_="on"} # Good!

Prometheus中的正则表达式使用[RE2语法](https://github.com/google/re2/wiki/Syntax)。

### 范围向量选择器

范围向量字面量的工作方式与即时向量字面量类似，不同之处在于它们从当前时刻选择了一系列样本。从语法上讲，在向量选择器的末尾将持续时间附加在方括号 (`[]`) 中，以指定应该为每个结果范围向量元素提取多远的时间值。

在下面的例子中，我们选取过去5分钟内所有`job`标签为`promethues`的`http_requests_total`指标：

> http_requests_total{job="prometheus"}[5m]

### 持续时间

持续时间是指其后紧跟下列单位的数字：

* `ms` 毫秒
* `s` 秒
* `m` 分钟
* `h` 小时
* `d` 天，一天总是24h
* `w` 周，一周总是7天
* `y` 年，一年总是365天

持续时间可以组合使用，但单位必须从大到小排列。在一个持续时间内，每个单位只能出现一次。

下面是一些可用的持续时间：

> 5h
> 1h30m
> 5m
> 10s

### offset修饰符

`offset`修饰符可以在查询过程中针对个别即时或者范围向量进行时间偏移。

例如，下面的表达式返回过去5分钟内的`http_requests_total`值：

> http_requests_total offset 5m

`offset`修饰符必须紧跟在选择器之后，例如下面的示例是合法的：

> sum(http_requests_total{method="GET"} offset 5m) // GOOD.

但这个是错误的：

> sum(http_requests_total{method="GET"}) offset 5m // INVALID.

范围向量也是一样的。下面的示例会返回一周前的`http_requests_total`5分钟的速率：

> rate(http_requests_total[5m] offset 1w)

为了与时间上的时间前移进行比较，可以指定负偏移量：

> rate(http_requests_total[5m] offset -1w)

此功能通过设置`--enable-feature=promql-negative-offset`标志启用。有关此标志的更多详细信息，请参见[功能标志](https://www.prometheus.io/docs/prometheus/latest/feature_flags/)。

### @修饰符

`@`修饰符允许在查询中更改单个瞬时向量和范围向量的计算时间。 提供`@`修饰符的时间是一个unix时间戳，用浮点字面值描述。

例如，下面的例子会返回`http_requests_total`在`2021-01-04T07:40:00+00:00`的值：

> http_requests_total @ 1609746000

`@`修饰符必须紧跟在选择器之后，例如下面的示例是合法的：

> sum(http_requests_total{method="GET"} @ 1609746000) // GOOD.

但这个是错误的：

> sum(http_requests_total{method="GET"}) @ 1609746000 // INVALID.

范围向量也是一样的。返回http_requests_total在2021年01月04日t07:40:00+00:00时的5分钟速率：

> rate(http_requests_total[5m] @ 1609746000)

`@`修饰符在`int64`范围内支持上述浮点字面值的所有表示。它还可以与`offset`修饰符一起使用，无论哪个修饰符先写，其中`offset`是相对于`@`修饰符时间应用的。这两个查询将产生相同的结果。

> # offset after @
> http_requests_total @ 1609746000 offset 5m
> # offset before @
> http_requests_total offset 5m @ 1609746000

默认情况下，这个修饰符是禁用的，因为它破坏了PromQL不能提前查看示例的评估时间的不变条件。它可以通过设置`——enable-feature=promql-at-modifier`标志来启用。有关此标志的详细信息，请参见[功能标志](https://www.prometheus.io/docs/prometheus/latest/feature_flags/)。

另外，`start()`和`end()`也可以作为@修饰符的值作为特殊值。

对于范围查询，它们分别解析到范围查询的开始和结束，并对所有步骤保持相同。

对于即时查询，`start()`和`end()`都解析为计算时间。

> http_requests_total @ start()
> rate(http_requests_total[5m] @ end())

## 子查询

子查询允许你针对给定的范围和分辨率运行即时查询。子查询的结果是一个范围向量。

语法：`<instant_query> '[' <range> ':' [<resolution>] ']' [ @ <float_literal> ] [ offset <duration> ]`

* \<resolution\>是可选项。默认值是全局计算间隔。

## 操作

Prometheus支持许多二进制和聚合操作符。这些在[表达式语言操作符](https://www.prometheus.io/docs/prometheus/latest/querying/operators/)页面中有详细描述。

## 函数

Prometheus支持几个对数据进行操作的函数。[表达式语言函数](https://www.prometheus.io/docs/prometheus/latest/querying/functions/)页面详细描述了这些函数。

## 注释

PromQL支持`#`开头的行注释：

> \# This is a comment

## 小贴士

### 过时

在运行查询时，抽样数据所在的时间戳将独立于当前的实际时间序列数据进行选择。这主要是为了支持像聚合(`sum`、`avg`等)这样的情况，在这种情况下，多个聚合时间序列不能在时间上精确对齐。由于它们的独立性，Prometheus需要在这些时间戳上为每个相关的时间序列分配一个值。它只需要在这个时间戳之前获取最新的样本即可。

如果目标刮擦或规则评估不再返回以前存在的时间序列的样本，则该时间序列将被标记为陈旧。如果删除了目标，那么之前返回的时间序列很快就会被标记为过时的。

如果在一个时间序列被标记为过时之后，在一个采样时间戳上计算查询，则不会为该时间序列返回值。如果随后在该时间序列中摄入了新的样本，它们将被正常退回。

如果在采样时间戳5分钟前没有找到样本(默认情况下)，则该时间序列在此时间点上没有返回值。这实际上意味着，当最新收集的样本时间超过5分钟，或者被标记为陈旧时，时间序列就会从图表中“消失”。

在时间序列中包含时间戳的时间序列将不会被标记为过时。在这种情况下，只应用5分钟阈值。

### 避免慢查询和过载

如果一个查询需要操作大量的数据，将其绘制成图形可能会超时或使服务器或浏览器超载。因此，在构建对未知数据的查询时，总是在Prometheus的表达式浏览器的表格视图中开始构建查询，直到结果集看起来合理为止(最多是数百个，而不是数千个时间序列)。只有当您充分地过滤或聚合数据时，才切换到图形模式。如果表达式仍然需要很长时间来绘制专门的图形，那么可以通过记录规则预先记录它。

这与Prometheus的查询语言特别相关，在这种语言中，像`api_http_requests_total`这样的指标名称选择器可以扩展到数千个带有不同标签的时间序列。还要记住，在多个时间序列上聚合的表达式将在服务器上生成负载，即使输出只是少量的时间序列。这类似于在关系数据库中对一列的所有值求和，即使输出值只是一个数字，也是很慢的。

