<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Meng`s Blog</title>
    <link>https://mengbin92.github.io/</link>
    <description>Recent content on Meng`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 20 Feb 2022 16:54:53 +0800</lastBuildDate>
    
        <atom:link href="https://mengbin92.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Prometheus Alertmanager</title>
      <link>https://mengbin92.github.io/post/prometheus/alertmanager/</link>
      <pubDate>Sun, 20 Feb 2022 16:54:53 +0800</pubDate>
      
      <guid>https://mengbin92.github.io/post/prometheus/alertmanager/</guid>
      
        <description>&lt;h1 id=&#34;prometheus-alertmanager&#34;&gt;Prometheus Alertmanager&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;告警能力在Prometheus中是独立出来的部分。如下图所示，通过在Prometheus中定义AlertRule（告警规则），Prometheus会周期性的对告警规则进行计算，如果满足告警触发条件就会向Alertmanager发送告警信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mengbin92.github.io/image/Prometheus/alert/alert.png&#34; alt=&#34;Prometheus告警处理&#34;&gt;&lt;/p&gt;
&lt;p&gt;Prometheus的告警规则一般有以下几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;告警名称：用户为告警规则命名，最好可以直接表达出该告警的主要内容&lt;/li&gt;
&lt;li&gt;告警规则：告警规则实际是一组PromQL，即当PromQL查询结果持续多长时间后发出告警&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Prometheus中，还可以通过Group（告警组）对一组相关的告警进行统一定义，这些定义都是通过YAML文件来统一管理的。&lt;/p&gt;
&lt;p&gt;Alertmanager是一个单独的组件，用以处理来自Prometheus Server或其它客户端的告警信息。它可以对这些信息进行进一步处理。比如，当接收到大量重复告警时能够消除重复的告警信息，同时对告警信息进行分组并且路由到正确的通知方。Prometheus内置了对邮件、Slack等多种方式的支持，同时还支持与Webhook集成，以支持更多定制化的场景。例如，Alertmanager目前不支持钉钉，那么我们可以给通过Webhook与钉钉机器人进行集成，从而通过钉钉接收告警信息。&lt;/p&gt;
&lt;p&gt;Alertmanager还提供了静默和告警抑制机制来对告警通知行为进行优化。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;alertmanager特性&#34;&gt;Alertmanager特性&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://mengbin92.github.io/image/Prometheus/alert/alert.png&#34; alt=&#34;Alertmanager特性&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;分组&#34;&gt;分组&lt;/h3&gt;
&lt;p&gt;分组机制可以将详细的告警信息合并成一个通知。在某些情况下，比如由于系统宕机导致大量的告警被同时触发，在这种情况下分组机制可以将这些被触发的告警合并为一个告警通知，避免一次性接受大量的告警通知，而无法对问题进行快速定位。&lt;/p&gt;
&lt;p&gt;例如，当集群中有数百个正在运行的服务实例，并且为每一个实例设置了告警规则。假如此时发生了网络故障，可能导致大量的服务实例无法连接到数据库，结果就会有数百个告警被发送到Alertmanager。&lt;/p&gt;
&lt;p&gt;而作为用户，可能只希望能够在一个通知中中就能查看哪些服务实例收到影响。这时可以按照服务所在集群或者告警名称对告警进行分组，而将这些告警内聚在一起成为一个通知。&lt;/p&gt;
&lt;p&gt;告警分组，告警时间，以及告警的接受方式可以通过Alertmanager的配置文件进行配置。&lt;/p&gt;
&lt;h3 id=&#34;抑制&#34;&gt;抑制&lt;/h3&gt;
&lt;p&gt;抑制是指当某一告警发出后，可以停止重复发送由此告警引发的其它告警的机制。&lt;/p&gt;
&lt;p&gt;例如，当集群不可访问时触发了一次告警，通过配置Alertmanager可以忽略与该集群有关的其它所有告警。这样可以避免接收到大量与实际问题无关的告警通知。&lt;/p&gt;
&lt;p&gt;抑制机制同样通过Alertmanager的配置文件进行设置。&lt;/p&gt;
&lt;h3 id=&#34;静默&#34;&gt;静默&lt;/h3&gt;
&lt;p&gt;静默提供了一个简单的机制可以快速根据标签对告警进行静默处理。如果接收到的告警符合静默的配置，Alertmanager则不会发送告警通知。&lt;/p&gt;
&lt;p&gt;静默设置需要在Alertmanager的Web页面上进行设置。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;prometheus告警规则&#34;&gt;Prometheus告警规则&lt;/h2&gt;
&lt;p&gt;Prometheus的告警规则实际是一组PromQL表达式定义的告警出发条件，由Prometheus后端对这些出发规则进行周期性计算，在满足触发条件时触发告警通知。默认情况下，用户可以通过Prometheus的Web界面查看这些告警规则以及告警的触发状态。当Promthues与Alertmanager关联之后，可以将告警发送到外部服务如Alertmanager中并通过Alertmanager可以对这些告警进行进一步的处理。&lt;/p&gt;
&lt;h3 id=&#34;定义告警规则&#34;&gt;定义告警规则&lt;/h3&gt;
&lt;p&gt;以下是一条典型的告警规则：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;groups&lt;/span&gt;:
- &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;example&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;rules&lt;/span&gt;:
  - &lt;span style=&#34;color:#f92672&#34;&gt;alert&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;HighErrorRate&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;expr&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;job:request_latency_seconds:mean5m{job=&amp;#34;myjob&amp;#34;} &amp;gt; 0.5&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;for&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;10m&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;labels&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;severity&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;page&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;annotations&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;summary&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;High request latency&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;description&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;description info&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在告警规则中，我们将一组相关的规则定义在一个group下，每个group下可以包含多条规则（rule）。通常一条告警规则包含以下几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;alert：告警规则名称。&lt;/li&gt;
&lt;li&gt;exper：基于PromQL的告警触发条件，用于计算是否有时间序列满足该条件。&lt;/li&gt;
&lt;li&gt;for：评估等待时间。可选项，用于表示只有触发条件持续一段时间后才发送告警。在等待期间新产生的告警的状态为pending。&lt;/li&gt;
&lt;li&gt;labels：自定义标签，允许用户指定要附加到告警信息的上的一组附加标签。&lt;/li&gt;
&lt;li&gt;annotations：指定一组附加信息，比如用于描述告警详细信息的文字等。annotations的内容在告警产生时会一同作为参数发送到Alertmanager。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Prometheus全局配置文件中，通过&lt;strong&gt;rule_file&lt;/strong&gt;指定告警规则文件的访问路径可以使Prometheus启用告警规则。Prometheus启动后自动扫描这些路径下的规文件中定义的内容，并根据这些规则计算是否向外部发送通知：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;rule_files&lt;/span&gt;:
  [ - &lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;lt;filepath_glob&amp;gt; ... ]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;默认情况下Prometheus会每分钟对这些规则进行计算，如果用户想自定义自己的告警计算周期，可以通过&lt;code&gt;evaluation_interval&lt;/code&gt;来覆盖默认的计算周期：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;global&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;[ evaluation_interval&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;lt;duration&amp;gt; | default = 1m ]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;模块化&#34;&gt;模块化&lt;/h3&gt;
&lt;p&gt;一般来说，在告警规则文件的annotations中使用&lt;code&gt;summary&lt;/code&gt;描述告警的概要信息，&lt;code&gt;description&lt;/code&gt;用于描述告警的详细信息。同时Alertmanager的UI也会根据这两个标签值，显示告警信息。为了让告警信息具有更好的可读性，Prometheus支持模板化label和annotations的中标签的值。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;$labels.&amp;lt;labelname&amp;gt;&lt;/code&gt;变量可以访问当前告警实例中指定标签的值。&lt;code&gt;$value&lt;/code&gt;则可以获取当前PromQL表达式计算的样本值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# To insert a firing element&amp;#39;s label values:&lt;/span&gt;
{{ &lt;span style=&#34;color:#ae81ff&#34;&gt;$labels.&amp;lt;labelname&amp;gt; }}&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# To insert the numeric expression value of the firing element:&lt;/span&gt;
{{ &lt;span style=&#34;color:#ae81ff&#34;&gt;$value }}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;例如，可以通过模板化优化summary以及description的内容的可读性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;groups&lt;/span&gt;:
- &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;example&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;rules&lt;/span&gt;:

  &lt;span style=&#34;color:#75715e&#34;&gt;# Alert for any instance that is unreachable for &amp;gt;5 minutes.&lt;/span&gt;
  - &lt;span style=&#34;color:#f92672&#34;&gt;alert&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;InstanceDown&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;expr&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;up == 0&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;for&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;5m&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;labels&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;severity&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;page&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;annotations&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;summary&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Instance {{ $labels.instance }} down&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;description&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes.&amp;#34;&lt;/span&gt;

  &lt;span style=&#34;color:#75715e&#34;&gt;# Alert for any instance that has a median request latency &amp;gt;1s.&lt;/span&gt;
  - &lt;span style=&#34;color:#f92672&#34;&gt;alert&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;APIHighRequestLatency&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;expr&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;api_http_request_latencies_second{quantile=&amp;#34;0.5&amp;#34;} &amp;gt; 1&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;for&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;10m&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;annotations&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;summary&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;High request latency on {{ $labels.instance }}&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;description&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{{ $labels.instance }} has a median request latency above 1s (current value: {{ $value }}s)&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;查看告警状态&#34;&gt;查看告警状态&lt;/h3&gt;
&lt;p&gt;如下图所示，用户可以通过Prometheus的Web界面中的Alerts菜单查看当前Prometheus下的所有告警规则，以及当前所处的活动状态：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;同时对于已经pending或者firing的告警，Prometheus也会将他们存储到时间序列ALERTS{}中。&lt;/p&gt;
&lt;p&gt;可以通过表达式，查询告警实例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ALERTS{alertname=&amp;quot;&amp;lt;alert name&amp;gt;&amp;quot;, alertstate=&amp;quot;pending|firing&amp;quot;, &amp;lt;additional alert labels&amp;gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;样本值为1表示当前告警处于活动状态（pending或者firing），当告警从活动状态转换为非活动状态时，样本值则为0。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>使用boot.iso镜像安装OL8</title>
      <link>https://mengbin92.github.io/post/others/%E4%BD%BF%E7%94%A8boot.iso%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85ol8/</link>
      <pubDate>Sun, 20 Feb 2022 16:43:47 +0800</pubDate>
      
      <guid>https://mengbin92.github.io/post/others/%E4%BD%BF%E7%94%A8boot.iso%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85ol8/</guid>
      
        <description>&lt;h1 id=&#34;使用bootiso镜像安装ol8&#34;&gt;使用boot.iso镜像安装OL8&lt;/h1&gt;
&lt;p&gt;本文记录使用boot.iso镜像安装Oracle Linux 8。&lt;/p&gt;
&lt;h2 id=&#34;镜像下载&#34;&gt;镜像下载&lt;/h2&gt;
&lt;p&gt;Oracle Linux 8 boot镜像可以从&lt;a href=&#34;http://yum.oracle.com/oracle-linux-isos.html&#34;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;Oracle Linux 8 boot镜像安装系统跟使用全镜像安装过程基本一样，除了需要自己手动配置&lt;strong&gt;软件源&lt;/strong&gt;，我这里使用的时Oracle官方提供的yum源：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;地址&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;baseos&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://yum.oracle.com/repo/OracleLinux/OL8/baseos/latest/x86_64&#34;&gt;https://yum.oracle.com/repo/OracleLinux/OL8/baseos/latest/x86_64&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Repository URL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ol8_AppStream&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://yum.oracle.com/repo/OracleLinux/OL8/appstream/x86_64/&#34;&gt;https://yum.oracle.com/repo/OracleLinux/OL8/appstream/x86_64/&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Repository URL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ol8_UEKR6&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;https://yum.oracle.com/repo/OracleLinux/OL8/UEKR6/x86_64/&#34;&gt;https://yum.oracle.com/repo/OracleLinux/OL8/UEKR6/x86_64/&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Repository URL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
      
    </item>
    
    <item>
      <title>ab使用</title>
      <link>https://mengbin92.github.io/post/others/ab%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 20 Feb 2022 16:42:42 +0800</pubDate>
      
      <guid>https://mengbin92.github.io/post/others/ab%E4%BD%BF%E7%94%A8/</guid>
      
        <description>&lt;h1 id=&#34;ab命令介绍&#34;&gt;ab命令介绍&lt;/h1&gt;
&lt;p&gt;网站性能压力测试是网站性能调优过程中必不可少的一个环节。只有服务器处于高压情况下，才能暴露出软件、硬件等各种设置的不当之处。&lt;/p&gt;
&lt;p&gt;性能测试的工具有很多，这里介绍主要介绍ab。&lt;/p&gt;
&lt;p&gt;ab是apache自带的压力测试工具，不仅可以对apache服务器进行网站访问压力测试，还可以对其它类型的服务器进行压力测试。&lt;/p&gt;
&lt;p&gt;ab全称apachebench，其工作原理是创建多个并发访问的线程，来模拟多个访问者同时对某个URL进行访问。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果已安装了apache服务，可以使用&lt;code&gt;which ab&lt;/code&gt;命令查看ab的安装位置。&lt;/li&gt;
&lt;li&gt;如果不想安装apache，又想使用ab命令，CentOS下可以使用&lt;code&gt;yum install -y httpd-tools&lt;/code&gt;来安装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安装完成后，执行&lt;code&gt;ab -V&lt;/code&gt;，会显示ab版本信息，如下图：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;参数说明&#34;&gt;参数说明&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ab --help&lt;/code&gt;可以查看ab命令的所有参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-n requests&lt;/strong&gt;：执行请求的数量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-c concurrency&lt;/strong&gt;：同一时间请求的并发量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-t timelimit&lt;/strong&gt;：单个测试最大时长，隐含&lt;code&gt;-n 50000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-s timeout&lt;/strong&gt;：每个响应的最长等待时间，默认30s&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-b windowsize&lt;/strong&gt;：TCP发送/接收缓存大小，字节为单位&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-B address&lt;/strong&gt;：外部连接时绑定的地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-p postfile&lt;/strong&gt;：包含POST数据的文件，需要与&lt;code&gt;-T&lt;/code&gt;一起使用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-u putfile&lt;/strong&gt;：包含PUT数据的文件，需要与&lt;code&gt;-T&lt;/code&gt;一起使用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-T content-type&lt;/strong&gt;：POST或PUT数据时指定Content-type头，例如&amp;rsquo;application/x-www-form-urlencoded&#39;，默认为&amp;rsquo;text/plain&#39;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-v verbosity&lt;/strong&gt;：输出排除信息的详尽程度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-w&lt;/strong&gt;：结果输出到HTML表格中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-i&lt;/strong&gt;：使用HEAD代替GET&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-x attributes&lt;/strong&gt;：设置table属性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-y attributes&lt;/strong&gt;：设置tr属性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-z attributes&lt;/strong&gt;：设置td或th属性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-C attributes&lt;/strong&gt;：添加cookie，例如&amp;rsquo;Apache=1234&#39;，可重复&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-H attributes&lt;/strong&gt;：添加header信息，例如&amp;rsquo;Accept-Encoding: gzip&#39;，在所有常用header后插入，可重复&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-A attributes&lt;/strong&gt;：添加基础WWW认证信息，属性值为冒号连接的用户名密码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-P attributes&lt;/strong&gt;：添加基础的代理信息，属性值为冒号连接的用户名密码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-X proxy:port&lt;/strong&gt;：使用的代理服务和端口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-V&lt;/strong&gt;：输出版本信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-k&lt;/strong&gt;：使用HTTP KeepAlive属性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-d&lt;/strong&gt;：不显示百分比服务表格&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-S&lt;/strong&gt;：不显示预估和告警信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-q&lt;/strong&gt;：当超过150条请求时不显示进度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-g filename&lt;/strong&gt;：测试结果输出到gnuplot格式的文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-e filename&lt;/strong&gt;：将百分比服务输出到CSV文件中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-r&lt;/strong&gt;：socket接收出错时不退出&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-h&lt;/strong&gt;：展示帮助信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-Z ciphersuite&lt;/strong&gt;：指定SSL/TLS加密套件（详见openssl ciphers）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-f protocol&lt;/strong&gt;：指定SSL/TLS协议（SSL3, TLS1, TLS1.1, TLS1.2 or ALL）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;性能指标&#34;&gt;性能指标&lt;/h2&gt;
&lt;p&gt;性能测试时主要关注以下几个性能指标：&lt;/p&gt;
&lt;h3 id=&#34;吞吐率requests-per-second&#34;&gt;吞吐率（Requests per second）&lt;/h3&gt;
&lt;p&gt;服务器并发处理能力的量化表示，单位reqs/s，指服务器单位时间内处理的并发请求数。&lt;/p&gt;
&lt;p&gt;吞吐率是基于并发用户的，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;吞吐率和并发用户数量有关&lt;/li&gt;
&lt;li&gt;不同并发用户数量下，吞吐率一般不同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该数值表示当前机器的整体性能，数值越大越好。&lt;/p&gt;
&lt;h3 id=&#34;单个请求等待时间&#34;&gt;单个请求等待时间&lt;/h3&gt;
&lt;p&gt;处理完所有请求花费的时间/（总请求数/并发用户数量）&lt;/p&gt;
&lt;h3 id=&#34;服务器平均等待时间&#34;&gt;服务器平均等待时间&lt;/h3&gt;
&lt;p&gt;处理完所有请求花费的时间/总请求数&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Golang Plugin介绍</title>
      <link>https://mengbin92.github.io/post/golang/plugin/</link>
      <pubDate>Sun, 20 Feb 2022 16:40:26 +0800</pubDate>
      
      <guid>https://mengbin92.github.io/post/golang/plugin/</guid>
      
        <description>&lt;h1 id=&#34;plugin&#34;&gt;Plugin&lt;/h1&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;以下内容来自&lt;a href=&#34;https://pkg.go.dev/plugin&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;go version： 1.17.5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;综述&#34;&gt;综述&lt;/h2&gt;
&lt;p&gt;plugin包实现了Go插件的加载和符号解析。&lt;/p&gt;
&lt;p&gt;Go插件是一个包括了可导出函数和变量的main包（可以没有main()函数），构建时使用如下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;go build -buildmode&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;plugin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;插件应该在程序的init函数中调用，且应该最先调用。插件只会被初始化一次，且无法被关闭。&lt;/p&gt;
&lt;p&gt;当前插件只支持Linux、FreeBSD和macOS。&lt;/p&gt;
&lt;h2 id=&#34;详细介绍&#34;&gt;详细介绍&lt;/h2&gt;
&lt;p&gt;plugin包中只包含两个结构：&lt;strong&gt;Plugin&lt;/strong&gt;和&lt;strong&gt;Symbol&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;plugin-1&#34;&gt;Plugin&lt;/h3&gt;
&lt;p&gt;plugin即为导入的插件。plugin包提供了两个方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;func Open(path string) (*Plugin, error)
加载Go插件。如果path指定的插件已经加载过，将返回已存在的 &lt;em&gt;*Plugin&lt;/em&gt;。该方法可在goroutines安全使用。&lt;/li&gt;
&lt;li&gt;func (p *Plugin) Lookup(symName string) (Symbol, error)
Lookup在插件p中查找名为symName的符号。符号可以是变量或者函数。符号不存在，则报错。该方法可在goroutines安全使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;symbol&#34;&gt;Symbol&lt;/h3&gt;
&lt;p&gt;Symbol是指针类型，可以是变量指针，也可以是函数指针。&lt;/p&gt;
&lt;h2 id=&#34;扩展&#34;&gt;扩展&lt;/h2&gt;
&lt;p&gt;plugin包中包含4个文件，&lt;strong&gt;plugin.go&lt;/strong&gt;、&lt;strong&gt;plugin_dlopen.go&lt;/strong&gt;、&lt;strong&gt;plugin_stubs.go&lt;/strong&gt;和&lt;strong&gt;plugin_test.go&lt;/strong&gt;，实现功能的是以下两个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;plugin.go 定义前一小节介绍的数据结构和函数&lt;/li&gt;
&lt;li&gt;plugin_dlopen.go 实现接口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看plugin_dlopen.go源码，不难发现Go插件功能的实现实际是依赖于&lt;strong&gt;C&lt;/strong&gt;语言中对动态库的解析，所以使用plugin时，需设置&lt;strong&gt;CGO_ENABLED=1&lt;/strong&gt;，否则plugin将无法使用。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Fabric区块链网络升级</title>
      <link>https://mengbin92.github.io/post/fabric/upgrade/</link>
      <pubDate>Sun, 20 Feb 2022 16:33:13 +0800</pubDate>
      
      <guid>https://mengbin92.github.io/post/fabric/upgrade/</guid>
      
        <description>&lt;h1 id=&#34;fabric网络升级&#34;&gt;fabric网络升级&lt;/h1&gt;
&lt;p&gt;原文地址在&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrade.html&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在fabric网络中，升级nodes和通道至最新版本需要四步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;备份账本和MSPs。&lt;/li&gt;
&lt;li&gt;以滚动的方式将orderer升级到最新版。&lt;/li&gt;
&lt;li&gt;以滚动的方式将peers升级到最新版。&lt;/li&gt;
&lt;li&gt;将orderer系统通道和所有可用的应用程序通道升级至最新版。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更多通道 capabilities信息，可以从&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/capabilities_concept.html&#34;&gt;这里&lt;/a&gt;了解。&lt;/p&gt;
&lt;p&gt;要了解以上的升级过程，可以查阅这些教程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrade_to_newest_version.html&#34;&gt;Considerations for getting to v2.x&lt;/a&gt; 介绍如何从之前的版本或其他长期支持版本升级至最新版。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrading_your_components.html&#34;&gt;Upgrading your components&lt;/a&gt; capabilities更新之前应该先升级组件。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/updating_capabilities.html&#34;&gt;Updating the capability level of a channel&lt;/a&gt; 完成所有节点的升级。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/enable_cc_lifecycle.html&#34;&gt;Enabling the new chaincode lifecycle&lt;/a&gt; 针对fabric v2.x，需要为新的chaincode lifecycle添加特定的背书策略。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在升级节点和增加通道的能力被认作是一个标准的Fabric过程，所以我们不再显示升级到最新版的命令。同样地，fabric-samples repo中也不会再提供脚本将示例网络升级到最新版。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;fabric网络升级到最新版之后，最好也将SDK升级至最新版。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;considerations-for-getting-to-v2x&#34;&gt;Considerations for getting to v2.x&lt;/h2&gt;
&lt;p&gt;本章节主要介绍如何从之前的版本或其他长期支持版本升级至最新版。&lt;/p&gt;
&lt;h3 id=&#34;从21升级到22&#34;&gt;从2.1升级到2.2&lt;/h3&gt;
&lt;p&gt;Fabric v2.1和v2.2都是稳定版，以bug修复和其它形式的代码加固位置。因此，升级不需要特别考虑，也不需要更新特定的镜像版本或通道配置更新。&lt;/p&gt;
&lt;h3 id=&#34;从v14x长期支持版本升级到v22&#34;&gt;从v1.4.x长期支持版本升级到v2.2&lt;/h3&gt;
&lt;p&gt;从v1.4.x升级到v2.2，你需要考虑一下内容：&lt;/p&gt;
&lt;h4 id=&#34;chaincode-lifecycle&#34;&gt;chaincode lifecycle&lt;/h4&gt;
&lt;p&gt;在chaincode被应用到通道前，允许多个组织表决该合约应该如何使用，这是v2.0新增的功能。要了解更多关于chaincode lifecycle的信息，可以参阅&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/chaincode_lifecycle.html&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;最佳操作是在启用使用了新的chaincode lifecycle的通道和应用程序之前，先升级通道中的所有peers节点（尽管通道 capabilities不是必须的，但此时更新它更有意义）。未更新至v2.x的peers节点都将会在启用任一capability后崩溃，未更新至v2的orderer节点会在启用通道 capability后崩溃。这种崩溃行为是有意义的，因为如果peers节点或orderer节点不支持必要的capabilities，那它将不能安全地参与到通道中。&lt;/p&gt;
&lt;p&gt;在通道更新应用程序的capabilities到v2.0之后，你必须使用v2.x lifecycle程序来打包、安装、审核和提交新的chaincode。因此，在更新功能之前，请确保为新的 lifecycle做好准备。&lt;/p&gt;
&lt;p&gt;新的lifecycle默认使用的背书策略是在配置在通道中的（例如 org中的&lt;code&gt;MAJORITY&lt;/code&gt;），因此通道启用capabilities时应将背书策略添加到通道的配置中。&lt;/p&gt;
&lt;p&gt;有关如何编辑相关通道配置以通过为每个组织添加背书策略的方式来启用行的lifecycle的信息，请查阅&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/enable_cc_lifecycle.html&#34;&gt;Enabling the new chaincode lifecycle&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;chaincode-shim包仅golang版&#34;&gt;chaincode shim包（仅Golang版）&lt;/h4&gt;
&lt;p&gt;在升级peers和通道之前，推荐使用&lt;strong&gt;vendor&lt;/strong&gt;来管理v1.4版本的Go chaincode使用的shim包。这样的话，你就无需更改的你的chaincode。&lt;/p&gt;
&lt;p&gt;Fabric网络升级后，如果你不使用vendor来管理你的shim包，尽管之前的chaincode镜像仍能正常工作，但这是有风险的。如果你的chaincode镜像从你的环境中删除了，那么v2.x的peer的invoke会重建chaincode镜像，但此时会报错，因为找不到shim包。&lt;/p&gt;
&lt;p&gt;此时，你有两个选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果整个通道都已经准备好升级chaincode，那你可以在所有的peers和通道上升级chaincode（至于使用旧的还是新的lifecycle，这取决于你启用的capability版本）。此时最好的方式是使用go mod来管理新的chaincode使用的shim包。&lt;/li&gt;
&lt;li&gt;如果整个通道都没有准备好升级chaincode，那你可以使用环境变量来指定的重建chaincode镜像时使用v1.4的&lt;code&gt;ccenv&lt;/code&gt;。v1.4的&lt;code&gt;ccenv&lt;/code&gt;仍可以在v2.x的peers上使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;chaincode日志仅golang版&#34;&gt;chaincode日志（仅Golang版）&lt;/h4&gt;
&lt;p&gt;chaincode shim包中的日志服务shim.ChaincodeLogger已被删除，所以需要用户自己选择日志服务。详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/logging-control.html#chaincode&#34;&gt;Logging control&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;peer数据库升级&#34;&gt;Peer数据库升级&lt;/h4&gt;
&lt;p&gt;关于如何升级peers节点的详细信息，可以参考&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrading_your_components.html&#34;&gt;upgrading components&lt;/a&gt;。在升级的你的peers节点之前，你还需要额外进行一步操作，那就是升级peer数据库。所有peers节点的数据库（不仅包括状态数据库，还包括历史数据库和peer节点的其它内部数据库）都必须使用v2.x的数据格式进行重建，这是升级到v2.x版本的一部分。要出发重建操作，在peers节点启动前需要删除数据库。接下来介绍如何使用&lt;code&gt;peer node upgrade-dbs&lt;/code&gt;命令来删除本地数据库并为升级做好准备，这样在启动v2.xpeers节点的第一时间，所有的数据库都会被重建。如果你使用CouchDB作为状态数据库，v2.2的peers已经支持自动删除CouchDB了。要启用该支持，需要你配置peer使用CouchDB，且在执行&lt;code&gt;upgrade-dbs&lt;/code&gt;命令前启动CouchDB。在v2.0和v2.1中，peer并不支持自动删除CouchDB数据库，你需要自己手动删除。&lt;/p&gt;
&lt;p&gt;在使用&lt;code&gt;docker run&lt;/code&gt;命令启动新的peer容器之后，再使用下面的命令来升级peer节点（你可以跳过设置&lt;code&gt;IMAGE_TAG&lt;/code&gt;的步骤，因为&lt;code&gt;upgrade-dbs&lt;/code&gt;只对v2.x Fabric有效。如果跳过的话，你需要设置&lt;code&gt;PEER_CONTAINER&lt;/code&gt;和&lt;code&gt;LEDGERS_BACKUP&lt;/code&gt; 环境变量）。使用下面的命令来代替&lt;code&gt;docker run&lt;/code&gt;命令启动peer的话，peer节点会删除本地的数据库，并为管理本地数据库做好准备（如果你是从v1.4.x版本升级的话，请使用v2.1代替v2.0）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker run --rm -v /opt/backup/$PEER_CONTAINER/:/var/hyperledger/production/ &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;            -v /opt/msp/:/etc/hyperledger/fabric/msp/ &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;            --env-file ./env&amp;lt;name of node&amp;gt;.list &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;            --name $PEER_CONTAINER &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;            hyperledger/fabric-peer:2.0 peer node upgrade-dbs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在v2.0和v2.1中，如果你使用的是CouchDB作为状态数据库，那么也需要删除CouchDB数据库。删除CouchDB的&lt;code&gt;/data&lt;/code&gt;目录即可。&lt;/p&gt;
&lt;p&gt;然后使用下面的命令来启动&lt;code&gt;2.0&lt;/code&gt;标签的peer：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker run -d -v /opt/backup/$PEER_CONTAINER/:/var/hyperledger/production/ &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;            -v /opt/msp/:/etc/hyperledger/fabric/msp/ &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;            --env-file ./env&amp;lt;name of node&amp;gt;.list &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;            --name $PEER_CONTAINER &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;            hyperledger/fabric-peer:2.0 peer node start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;peer节点会在启动之后立即使用v2.x数据格式重建数据库。由于重建数据库可能是一个漫长的过程（这取决于你的数据库大小，可能长达数小时），所以需要实时检查peer节点的日志来确认重建的进度。每隔1000个区块，你会看到如下信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;[lockbasedtxmgr] CommitLostBlock -&amp;gt; INFO 041 Recommitting block [1000] to state database&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;表示数据库还在重建中。&lt;/p&gt;
&lt;p&gt;如果升级过程中没有删除数据库，在peer节点启动时会返回错误信息：&lt;strong&gt;peer节点使用的是老旧的数据格式，必须使用&lt;code&gt;peer node upgrade-dbs&lt;/code&gt;命令删除上述数据库（如果使用CouchDB作为状态数据库，则需要手动删除）&lt;/strong&gt;。处理完成后重启节点即可。&lt;/p&gt;
&lt;h4 id=&#34;capability&#34;&gt;Capability&lt;/h4&gt;
&lt;p&gt;v2.0新增了下面三个Capabilities：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Application &lt;code&gt;V2_0&lt;/code&gt;&lt;/strong&gt;: 如&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/chaincode_lifecycle.html&#34;&gt;Fabric chaincode lifecycle&lt;/a&gt;章节所述，启用了新的chaincode lifecycle。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通道 &lt;code&gt;V2_0&lt;/code&gt;&lt;/strong&gt;：无更新，但与application和orderer版本保持一致。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Orderer &lt;code&gt;V2_0&lt;/code&gt;&lt;/strong&gt;：控制&lt;code&gt;Use通道CreationPolicyAsAdmins&lt;/code&gt;，可修改通道创建交易的验证方式。当configtxgen与&lt;code&gt;-bashProfile&lt;/code&gt;选项联用时，可重置从orderer系统通道继承的值。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与Capability版本更新一样，更新&lt;code&gt;Application&lt;/code&gt;和&lt;code&gt;通道&lt;/code&gt;之前，确保已经升级的了你的peer可执行文件，更新&lt;code&gt;Orderer&lt;/code&gt;和&lt;code&gt;通道&lt;/code&gt;之前，确保已经升级的了你的orderer可执行文件。&lt;/p&gt;
&lt;p&gt;关于如何设置新的Capabilities，详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/updating_capabilities.html&#34;&gt;Updating the capability level of a 通道&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;为每个组织配置orderer终端推荐配置&#34;&gt;为每个组织配置orderer终端（推荐配置）&lt;/h4&gt;
&lt;p&gt;从v1.4.2开始，推荐在组织版本为所有的系统通道和应用程序通道定义orderer终端，可以在组织的通道配置中新增&lt;code&gt;OrdererEndpoints&lt;/code&gt;来替代全局的&lt;code&gt;OrdererAddresses&lt;/code&gt;。如果有一个组织设置了组织版本的的orderer服务终端，那么在连接orderer节点时，所有的orderers和peers都会忽略通道版本的终端。&lt;/p&gt;
&lt;p&gt;当服务发现与多个组织提供的orderer节点一起使用时，那就必须使用组织版本的orderer终端。这需要客户端配置正确的TLS证书。&lt;/p&gt;
&lt;p&gt;如果你的通道配置中每个组织都未包含&lt;code&gt;OrdererEndpoints&lt;/code&gt;，那你需要升级你的通道配置来给它们添加这一配置。首先需要创建一个包含新配置章节的JSON文件。&lt;/p&gt;
&lt;p&gt;在这个例子中，我们将为名为&lt;code&gt;OrdererOrg&lt;/code&gt;的组织添加配置。如果你有多个提供orderer服务的组织，那么每个组织都需要添加配置。JSON文件&lt;code&gt;orglevelEndpoints.json&lt;/code&gt;内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;OrdererOrgEndpoint&amp;#34;&lt;/span&gt;: {
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Endpoints&amp;#34;&lt;/span&gt;: {
          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;mod_policy&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Admins&amp;#34;&lt;/span&gt;,
          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;: {
              &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;addresses&amp;#34;&lt;/span&gt;: [
                 &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;127.0.0.1:30000&amp;#34;&lt;/span&gt;
              ]
          }
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后，导入如下配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;CH_NAME&lt;!-- raw HTML omitted --&gt;：待更新的通道名称。所有的系统通道和应用程序通道都应该包含排序节点的组织终端。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;CORE_PEER_LOCALMSPID&lt;!-- raw HTML omitted --&gt;：提出通道更新的组织的MSPID。排序组织的MSP之一。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;CORE_PEER_MSPCONFIGPATH&lt;!-- raw HTML omitted --&gt;：标识你的组织的MSP的绝对路径。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;TLS_ROOT_CA&lt;!-- raw HTML omitted --&gt;：提出系统通道更新的组织根证书的绝对路径。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;ORDERER_CONTAINER&lt;!-- raw HTML omitted --&gt;：排序节点的容器名称。访问排序服务时，你可以访问提供排序服务的任何排序节点。你的请求会自动提交给leader节点。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;ORGNAME&lt;!-- raw HTML omitted --&gt;：当前你要更新的组织名称，例如&lt;code&gt;OrdererOrg&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当你设置好环境变量后，就可以按照&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-1-pull-and-translate-the-config&#34;&gt;Step 1: Pull and translate the config&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;之后使用下面的命令将组织的lifecycle策略（&lt;code&gt;orglevelEndpoints.json&lt;/code&gt;文件中配置的）添加到名为&lt;code&gt;modified_config&lt;/code&gt;的文件中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;jq -s &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.[0] * {\&amp;#34;通道_group\&amp;#34;:{\&amp;#34;groups\&amp;#34;:{\&amp;#34;Orderer\&amp;#34;: {\&amp;#34;groups\&amp;#34;: {\&amp;#34;&lt;/span&gt;$ORGNAME&lt;span style=&#34;color:#e6db74&#34;&gt;\&amp;#34;: {\&amp;#34;values\&amp;#34;: .[1].&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;ORGNAME&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Endpoint}}}}}}&amp;#34;&lt;/span&gt; config.json ./orglevelEndpoints.json &amp;gt; modified_config.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后的操作，详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-3-re-encode-and-submit-the-config&#34;&gt;Step 3: Re-encode and submit the config&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果排序服务组织执行它们自己的通道编辑操作，那么它们可以在没有进一步签名（默认情况下，编辑组织内部参数只需要该组织管理员的签名）的情况下编辑配置。如果不同组织执行更新，那就需要被编辑的组织对更新请求进行签名。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;更新你的组件&#34;&gt;更新你的组件&lt;/h2&gt;
&lt;p&gt;如果想了解最新版Fabric的特殊事项，详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrade_to_newest_version.html&#34;&gt;Upgrading to the latest release of Fabric&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本章只介绍更新Fabric组件的操作。关于如何通过编辑通道来改变你通道的capability版本，详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/updating_capabilities.html&#34;&gt;Updating a 通道 capability&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：在Hyperledger Fabric中使用术语&lt;strong&gt;升级&lt;/strong&gt;时，指的是升级组件的版本（例如，将可执行文件升级到最新版）。使用&lt;strong&gt;更新&lt;/strong&gt;时，指的是配置的更新，例如更新通道的配置或部署脚本。在Fabric中，如果没有数据&lt;strong&gt;迁移&lt;/strong&gt;的话，我们不会使用术语&lt;strong&gt;迁移&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;总览&#34;&gt;总览&lt;/h3&gt;
&lt;p&gt;整体来看，在可执行程序层面升级你的节点，分两步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;备份账本和MSPs&lt;/li&gt;
&lt;li&gt;更新所有的可执行程序到最新版&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你拥有排序节点和peers，最好的做法是先升级排序节点。peer节点版本滞后或暂时无法处理某些交易，之后它总是可以赶上的。但如果相当数量的排序节点宕机，那Fabric网络将无法提供服务。&lt;/p&gt;
&lt;p&gt;本文所有的操作都是通过Docker CLI命令执行。如果你使用其它的部署方法（Rancher，Kubernetes，OpenShift，等等），请查阅它的文档了解其CLI如何使用。&lt;/p&gt;
&lt;p&gt;对于本机部署的，你还需要更新节点的YAML配置文件，例如&lt;code&gt;orderer.yaml&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;备份&lt;code&gt;orderer.yaml&lt;/code&gt;或&lt;code&gt;core.yaml&lt;/code&gt;（peer节点），然后使用最新发布版中的&lt;code&gt;orderer.yaml&lt;/code&gt;或&lt;code&gt;core.yaml&lt;/code&gt;来替换它们。之后将备份的&lt;code&gt;orderer.yaml&lt;/code&gt;或&lt;code&gt;core.yaml&lt;/code&gt;文件中修改的地方更新到新的文件中。可以使用&lt;code&gt;diff&lt;/code&gt;来协助。注意，更新YAML文件时，推荐使用最新发布的来替换原有的，这样可以减少很多错误。&lt;/p&gt;
&lt;p&gt;本文是假设你是使用Docker来部署Fabric网络的，YAML文件都已经内嵌到docker镜像中，配置文件中的默认值可以通过环境变量覆盖。&lt;/p&gt;
&lt;h3 id=&#34;环境变量配置&#34;&gt;环境变量配置&lt;/h3&gt;
&lt;p&gt;在部署peer或order节点时，你需要设置大量跟配置相关的环境变量。最好的做法是将这些环境记录在与要部署相关节点相关的文件中，并保存到本地。这样，在更新节点时可以保证你使用的是更节点创建是一样的环境变量。&lt;/p&gt;
&lt;p&gt;下面是&lt;strong&gt;peer&lt;/strong&gt;相关的一系列环境变量（这些环境变量是本地部署使用的）可以放在文件中，你可能并不需要用到下面所有的环境变量：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CORE_PEER_TLS_ENABLED=true
CORE_PEER_GOSSIP_USELEADERELECTION=true
CORE_PEER_GOSSIP_ORGLEADER=false
CORE_PEER_PROFILE_ENABLED=true
CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/tls/server.crt
CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/tls/server.key
CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/tls/ca.crt
CORE_PEER_ID=peer0.org1.example.com
CORE_PEER_ADDRESS=peer0.org1.example.com:7051
CORE_PEER_LISTENADDRESS=0.0.0.0:7051
CORE_PEER_CHAINCODEADDRESS=peer0.org1.example.com:7052
CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:7052
CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org1.example.com:7051
CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:7051
CORE_PEER_LOCALMSPID=Org1MSP
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是&lt;strong&gt;orderer&lt;/strong&gt;相关的一系列环境变量（这些环境变量是本地部署使用的）可以放在文件中，你可能并不需要用到下面所有的环境变量：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ORDERER_GENERAL_LISTENADDRESS=0.0.0.0
ORDERER_GENERAL_GENESISMETHOD=file
ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block
ORDERER_GENERAL_LOCALMSPID=OrdererMSP
ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp
ORDERER_GENERAL_TLS_ENABLED=true
ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key
ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt
ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]
ORDERER_GENERAL_CLUSTER_CLIENTCERTIFICATE=/var/hyperledger/orderer/tls/server.crt
ORDERER_GENERAL_CLUSTER_CLIENTPRIVATEKEY=/var/hyperledger/orderer/tls/server.key
ORDERER_GENERAL_CLUSTER_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你需要为每个你想升级的节点设置环境变量。&lt;/p&gt;
&lt;h3 id=&#34;账本备份与还原&#34;&gt;账本备份与还原&lt;/h3&gt;
&lt;p&gt;虽然我们将在本教程中演示备份账本数据的过程，但并不严格要求备份peer或排序节点（提供排序服务的一组排序节点之一）的账本数据。因为即使是最坏的情况下（例如硬盘故障），peer节点也能在没有账本的情况下启动。之后你再将peer节点重新加入到期望的通道中，peer节点会自动为每个通道创建账本，并周期性的从排序符合或其它peer节点中接受区块数据。在处理区块的过程中，peer节点会构建它自己的状态数据库。&lt;/p&gt;
&lt;p&gt;但是，备份账本数据可以直接还原peer节点，不需要考虑从创世块构建数据和重新处理所有交易所花费的时间和计算成本，这一通过通常会花费数小时（取决于账本的大小）。此外，账本数据的备份还可能有助于新增peer节点，它可以从现有的peer节点获取账本数据来启动自己。&lt;/p&gt;
&lt;p&gt;本文假定账本数据存放的文件路径并没有改变，还放在默认的路径：&lt;code&gt;/var/hyperledger/production/&lt;/code&gt;(peer节点)或&lt;code&gt;/var/hyperledger/production/orderer&lt;/code&gt;（排序节点）。如果你的路径改变了，那么在执行下面的命令时就需要输入你存放账本数据的路径。&lt;/p&gt;
&lt;p&gt;需要注意的是账本和chaincodes数据都保存在该路径下。最好的做法是将两者都进行备份，这样做的话会忽略&lt;code&gt;/var/hyperledger/production/ledgersData&lt;/code&gt;下的&lt;code&gt;stateLeveldb&lt;/code&gt;、&lt;code&gt;historyLeveldb&lt;/code&gt;和&lt;code&gt;chains/index&lt;/code&gt;目录。尽管这样可以减少备份所需的存储空间，但peer从备份的数据中恢复时可能会花费更多的时间，因为这些账本会在peer启动时重新构建。&lt;/p&gt;
&lt;p&gt;如果使用CouchDB作为状态数据库，那么默认路径下是没有&lt;code&gt;stateLeveldb&lt;/code&gt;的，因为状态数据库的数据会存如CouchDB中。同样的，如果peer启动时找不到CouchDB数据库或块高较小（基于早先的CouchDB备份），状态数据库会自动地重构数据直至当前块高。所以，如果你分别备份peer的账本数据和CouchDB数据，那么你需要确保CouchDB备份总早于peer的备份。&lt;/p&gt;
&lt;h3 id=&#34;升级排序节点&#34;&gt;升级排序节点&lt;/h3&gt;
&lt;p&gt;排序节点应该以滚动的方式进行升级（在一次升级过程中）。总体来讲，排序节点的更新步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关闭排序节点。&lt;/li&gt;
&lt;li&gt;备份排序节点的账本和MSP。&lt;/li&gt;
&lt;li&gt;移除排序节点容器。&lt;/li&gt;
&lt;li&gt;使用相应的镜像启动新的排序节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在排序服务的所有节点上重复执行上面的过程，直至整个排序服务都完成升级。&lt;/p&gt;
&lt;h4 id=&#34;设置环境变量&#34;&gt;设置环境变量&lt;/h4&gt;
&lt;p&gt;在更新排序节点前导入以下环境变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;ORDERER_CONTAINER&lt;!-- raw HTML omitted --&gt;：排序节点的容器名称。注意，每个节点更新时你都样设置一遍。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;LEDGERS_BACKUP&lt;!-- raw HTML omitted --&gt;：存放备份数据的路径。就如下面的示例中，每个节点都有它自己的子目录来存放它的账本。目录如果不存在的话，你需要手动创建。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;IMAGE_TAG&lt;!-- raw HTML omitted --&gt;：你期望升级到的Fabric版本，例如v2.0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，&lt;strong&gt;镜像标签&lt;/strong&gt;是必须设置，这样才能确保你使用正确的镜像来启动节点。设置标签的过程取决你的部署方式。&lt;/p&gt;
&lt;h4 id=&#34;升级容器&#34;&gt;升级容器&lt;/h4&gt;
&lt;p&gt;开始更新之前，我们需要先&lt;strong&gt;下线排序节点&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker stop $ORDERER_CONTAINER
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;服务下线后，你就可以&lt;strong&gt;备份账本和MSP&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker cp $ORDERER_CONTAINER:/var/hyperledger/production/orderer/ ./$LEDGERS_BACKUP/$ORDERER_CONTAINER
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后删除排序服务容器（因为我们需要新容器与现有的容器同名）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker rm -f $ORDERER_CONTAINER
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，启用新的排序节点容器：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker run -d -v /opt/backup/$ORDERER_CONTAINER/:/var/hyperledger/production/orderer/ &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;            -v /opt/msp/:/etc/hyperledger/fabric/msp/ &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;            --env-file ./env&amp;lt;name of node&amp;gt;.list &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;            --name $ORDERER_CONTAINER &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;            hyperledger/fabric-orderer:$IMAGE_TAG orderer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当所有的排序节点都完成升级，你就可以开始升级peer节点。&lt;/p&gt;
&lt;h3 id=&#34;升级peer节点&#34;&gt;升级peer节点&lt;/h3&gt;
&lt;p&gt;与排序节点升级一样，peer节点也应该以滚动的方式进行升级（在一次升级过程中）。正如排序节点升级时提到的，排序节点的升级和peer节点的升级是可以并行的，但在本教程中我们是串行执行这两个过程。总体来看，peer节点的升级需要以下几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下线peer节点。&lt;/li&gt;
&lt;li&gt;备份peer账本和MSP。&lt;/li&gt;
&lt;li&gt;移除chaincode容器和镜像。&lt;/li&gt;
&lt;li&gt;移除peer容器。&lt;/li&gt;
&lt;li&gt;使用相应的镜像启动新的peer容器。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;设置环境变量-1&#34;&gt;设置环境变量&lt;/h4&gt;
&lt;p&gt;在更新peer节点前导入以下环境变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;PEER_CONTAINER&lt;!-- raw HTML omitted --&gt;：peer节点的容器名称。注意，每个节点更新时你都样设置一遍。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;LEDGERS_BACKUP&lt;!-- raw HTML omitted --&gt;：存放备份数据的路径。就如下面的示例中，每个节点都有它自己的子目录来存放它的账本。目录如果不存在的话，你需要手动创建。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;IMAGE_TAG&lt;!-- raw HTML omitted --&gt;：你期望升级到的Fabric版本，例如v2.0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，&lt;strong&gt;镜像标签&lt;/strong&gt;是必须设置，这样才能确保你使用正确的镜像来启动节点。设置标签的过程取决你的部署方式。&lt;/p&gt;
&lt;p&gt;在所有peer节点上重复执行上面的过程，以便完成所有peer节点的升级。&lt;/p&gt;
&lt;h4 id=&#34;升级容器-1&#34;&gt;升级容器&lt;/h4&gt;
&lt;p&gt;首先，使用下面的命令来&lt;strong&gt;下线peer节点&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker stop $PEER_CONTAINER
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后&lt;strong&gt;备份peer账本和MSP&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker cp $PEER_CONTAINER:/var/hyperledger/production ./$LEDGERS_BACKUP/$PEER_CONTAINER
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在完成peer节点下线和账本备份后，&lt;strong&gt;移除peerchaincode容器和镜像&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;CC_CONTAINERS&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;docker ps | grep dev-$PEER_CONTAINER | awk &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt; -n &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$CC_CONTAINERS&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; ; &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt; docker rm -f $CC_CONTAINERS ; &lt;span style=&#34;color:#66d9ef&#34;&gt;fi&lt;/span&gt;

CC_IMAGES&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;docker images | grep dev-$PEER | awk &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt; -n &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$CC_IMAGES&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; ; &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt; docker rmi -f $CC_IMAGES ; &lt;span style=&#34;color:#66d9ef&#34;&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后删除peer容器（因为我们需要新容器与现有的容器同名）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker rm -f $PEER_CONTAINER
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，启动新的peer容器：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker run -d -v /opt/backup/$PEER_CONTAINER/:/var/hyperledger/production/ &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;            -v /opt/msp/:/etc/hyperledger/fabric/msp/ &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;            --env-file ./env&amp;lt;name of node&amp;gt;.list &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;            --name $PEER_CONTAINER &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;            hyperledger/fabric-peer:$IMAGE_TAG peer node start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;chaincode容器并不需要手动启动。在收到chaincode请求时（invoke或query），peer首先会检查chaincode是否在运行。如果是，直接使用；如果没有的话，peer节点会启动chaincode（必要时会重建chaincode镜像）。&lt;/p&gt;
&lt;h4 id=&#34;验证peer升级完成&#34;&gt;验证peer升级完成&lt;/h4&gt;
&lt;p&gt;确认peer是否完成升级最好的方法是一次chaincode调用请求。注意，查询操作只能确定账本所在的单个peer节点成功升级。如果你想确认多个peer节点是否升级完成，同时更新chaincode也是升级操作的一部分的话，那你应该等到符合背书策略、且来自足够多组织的peer节点完成升级之后在进行验证。&lt;/p&gt;
&lt;p&gt;在你计划验证之前，你需要升级来自足够多的组织的peer节点，以满足你的背书策略。但只有将更新chaincode作为升级peer操作的一部分时，才需要这样做。如果你的升级操作中不包括更新chaincode，那验证peer升级是否完成的操作可能会得到运行不同Fabric版本的peer节点的背书。&lt;/p&gt;
&lt;h3 id=&#34;升级ca&#34;&gt;升级CA&lt;/h3&gt;
&lt;p&gt;要了解如何升级你的Fabric CA服务，详见&lt;a href=&#34;http://hyperledger-fabric-ca.readthedocs.io/en/latest/users-guide.html#upgrading-the-server&#34;&gt;CA documentation&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;升级-nodejs-sdk&#34;&gt;升级 Node.js SDK&lt;/h3&gt;
&lt;p&gt;升级Node.js SDK前需要先升级Fabric和Fabric CA。Fabric和Fabric CA兼容旧版的SDK。在旧版的Fabric和Fabric CA上使用较新的SDK，通常会提示旧版的Fabric和Fabric CA部分功能不可用，且兼容性并未经过测试。&lt;/p&gt;
&lt;p&gt;在你应用程序的根目录下执行下面的命令可以升级所有的&lt;code&gt;Node.js&lt;/code&gt;客户端：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;npm install fabric-client@latest

npm install fabric-ca-client@latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的命令安装最新版的Fabric和Fabric CA客户端，并将版本信息写入&lt;code&gt;package.json&lt;/code&gt;中。&lt;/p&gt;
&lt;h3 id=&#34;升级couchdb&#34;&gt;升级CouchDB&lt;/h3&gt;
&lt;p&gt;如果使用CouchDB作为状态数据库，那么在你升级peer节点也要同步升级CouchDB。&lt;/p&gt;
&lt;p&gt;升级CouchDB：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下线CouchDB。&lt;/li&gt;
&lt;li&gt;备份CouchDB数据目录。&lt;/li&gt;
&lt;li&gt;安装最新版的CouchDB或更新部署脚本启用新的Docker镜像。&lt;/li&gt;
&lt;li&gt;重启CouchDB。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;升级node-chaincode&#34;&gt;升级Node chaincode&lt;/h3&gt;
&lt;p&gt;要升级到新版的Node chaincode shim包，开发人员需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;更新chaincode&lt;code&gt;package.json&lt;/code&gt;中的&lt;code&gt;fabric-shim&lt;/code&gt;至新版。&lt;/li&gt;
&lt;li&gt;重新打包新的chaincode包，并在通道的所有背书节点上进行安装。&lt;/li&gt;
&lt;li&gt;升级新到新的chaincode，详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerchaincode.html&#34;&gt;Peer chaincode commands&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;升级go-chaincode&#34;&gt;升级Go chaincode&lt;/h3&gt;
&lt;p&gt;关于升级Go chaincode到v2.0版，详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrade_to_newest_version.html#chaincode-shim-changes&#34;&gt;Chaincode shim changes&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;有大量的第三方工具来帮你管理你的chaincode shim包。选择你熟悉的方式来管理你的chaincode shim包，并重新打包你的chaincode。&lt;/p&gt;
&lt;p&gt;如果你更新了chaincode shim包，那你必须在所有已安装改chaincode的peer节点上重新安装它。安装时使用相同的名称，不同的版本号。之后你还要在部署了该chaincode的所有通道上执行chaincode升级操作来升级chaincode。&lt;/p&gt;
&lt;h2 id=&#34;更新通道的capability版本&#34;&gt;更新通道的capability版本&lt;/h2&gt;
&lt;p&gt;如果不熟悉capability，那么操作前可以查阅&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/capabilities_concept.html&#34;&gt;Capabilities&lt;/a&gt;。需要注意的是&lt;strong&gt;在启用capabilities前，需要升级归属该通道的peer节点和排序节点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;更多关于最新版Fabric中capabilities版本的信息，详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrade_to_newest_version.html#Capabilities&#34;&gt;Upgrading your components&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：在Hyperledger Fabric中使用术语&lt;strong&gt;升级&lt;/strong&gt;时，指的是升级组件的版本（例如，将可执行文件升级到最新版）。使用&lt;strong&gt;更新&lt;/strong&gt;时，指的是配置的更新，例如更新通道的配置或部署脚本。在Fabric中，如果没有数据&lt;strong&gt;迁移&lt;/strong&gt;的话，我们不会使用术语&lt;strong&gt;迁移&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;先决条件和注意事项&#34;&gt;先决条件和注意事项&lt;/h3&gt;
&lt;p&gt;更新前，请先确保你的机器上有&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/prereqs.html&#34;&gt;Prerequisites&lt;/a&gt;中所提及的所有依赖。这将保证你拥有更新通道配置所需的最新版工具。&lt;/p&gt;
&lt;p&gt;由于Fabric可以并且应该滚动更新，所以&lt;strong&gt;启用capabilities前需要完成Fabric的升级&lt;/strong&gt;。任何没有升级到至少capabilities相关的可执行程序都将引起崩溃，并指出错误的配置，否则会导致账本分叉。&lt;/p&gt;
&lt;p&gt;一旦启用capabilities，它成为该通道的永久记录。这意味着即使之后禁用了capabilities，旧的可执行程序也无法参与到该通道中，因为它无法处理启用capabilities到禁用capabilities期间的所有区块。结果就是一旦启用了capabilities，就不建议或不支持禁用它。&lt;/p&gt;
&lt;p&gt;有鉴于此，可将启用capabilities视为不可逆的。所以在测试设置新capabilities，并在生成环境下启用之前，请三思。&lt;/p&gt;
&lt;h3 id=&#34;概览&#34;&gt;概览&lt;/h3&gt;
&lt;p&gt;在接下来的教程中，我们将展示如何在所有的系统通道和应用程序通道中配置capabilities更新。&lt;/p&gt;
&lt;p&gt;是否需要为所有的通道更新配置的每个部分，这取决于最新版的内容以及你的使用场景。详情参见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrade_to_newest_version.html&#34;&gt;Upgrading to the latest version of Fabric&lt;/a&gt;。需要注意的是在使用最新版功能前，可能需要更新到最新的capability版本，最好的做法是始终使用最新版的可执行程序和最新的capability版本。&lt;/p&gt;
&lt;p&gt;因为更新capability版本涉及到配置更新事务流程，相关命令详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html&#34;&gt;Updating a 通道 configuration&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;与通道其它配置更新一样，capability版本更新也分三步（每个通道）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取最新的通道配置&lt;/li&gt;
&lt;li&gt;创建修改后的通道配置&lt;/li&gt;
&lt;li&gt;创建配置更新事务&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们将按照下面的顺序来启用capabilities：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/updating_capabilities.html#orderer-system-%E9%80%9A%E9%81%93-capabilities&#34;&gt;Orderer system 通道&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;Orderer group&lt;/li&gt;
&lt;li&gt;通道 group&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/updating_capabilities.html#enable-capabilities-on-existing-%E9%80%9A%E9%81%93&#34;&gt;Application 通道&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;Orderer group&lt;/li&gt;
&lt;li&gt;通道 group&lt;/li&gt;
&lt;li&gt;Application group&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;尽管可以同时编辑通道配置的多个部分，但在本教程中我们将展示如何逐步处理这些过程。也就是说我们不会在一次配置修改中同时修改系统通道的&lt;code&gt;Orderer&lt;/code&gt;组和&lt;code&gt;通道&lt;/code&gt;组。这是因为并不是每次发布都有新的&lt;code&gt;Orderer&lt;/code&gt;组capability和&lt;code&gt;通道&lt;/code&gt;组capability。&lt;/p&gt;
&lt;p&gt;在生成网络中，单个用户可以独立完成所有通道（和其它配置）更新时不可能的，也是不明智的。例如，orderer system 通道更新，只能由组织的管理员来执行（尽管可以将peer组织添加到排序服务组织中）。同样地，更新其它的&lt;code&gt;Orderer&lt;/code&gt;或&lt;code&gt;通道&lt;/code&gt;组的通道配置除了需要排序服务组织的签名外还需要peer组织的签名。分布式系统需要协同管理。&lt;/p&gt;
&lt;h4 id=&#34;新建capabilities配置文件&#34;&gt;新建capabilities配置文件&lt;/h4&gt;
&lt;p&gt;本教程假设名为&lt;code&gt;capabilities.json&lt;/code&gt;的文件已创建，它包含所有你想更新的capabilities。使用&lt;code&gt;jq&lt;/code&gt;将编辑的配置应用到修改后的文件中。&lt;/p&gt;
&lt;p&gt;你也不是非要创建类似&lt;code&gt;capabilities.json&lt;/code&gt;的文件或使用&lt;code&gt;jq&lt;/code&gt;工具。修改后的配置也可手动编辑，详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#sample-%E9%80%9A%E9%81%93-configuration&#34;&gt;sample 通道 configuration&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;然而，这里所描述的过程（使用JSON文件和&lt;code&gt;jq&lt;/code&gt;工具）在脚本化方面确实有优势，这使得它适合想大量的通道进行配置更新。这也是这种方式为什么会成为&lt;strong&gt;更新通道的推荐方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;示例中，&lt;code&gt;capabilities.json&lt;/code&gt;文件内容如下（如果将更新通道作为你&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrade_to_newest_version.html&#34;&gt;Fabric升级到最新版&lt;/a&gt;的一部分，则需要将capabilities设置为适合该版本的版本）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
     &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;通道&amp;#34;&lt;/span&gt;: {
         &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;mod_policy&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Admins&amp;#34;&lt;/span&gt;,
             &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;: {
                 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;capabilities&amp;#34;&lt;/span&gt;: {
                     &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;V2_0&amp;#34;&lt;/span&gt;: {}
                 }
             },
         &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;
     },
     &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;orderer&amp;#34;&lt;/span&gt;: {
         &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;mod_policy&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Admins&amp;#34;&lt;/span&gt;,
             &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;: {
                 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;capabilities&amp;#34;&lt;/span&gt;: {
                     &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;V2_0&amp;#34;&lt;/span&gt;: {}
                 }
             },
         &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;
     },
     &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;application&amp;#34;&lt;/span&gt;: {
         &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;mod_policy&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Admins&amp;#34;&lt;/span&gt;,
             &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;: {
                 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;capabilities&amp;#34;&lt;/span&gt;: {
                     &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;V2_0&amp;#34;&lt;/span&gt;: {}
                 }
             },
         &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;
     }
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;默认情况下，peer节点并不是orderer system 通道的管理员，所以peer节点不能发起orderer system 通道配置更新。排序组织的管理员必须创建类似的文件（没&lt;code&gt;application&lt;/code&gt;组capability，因为系统通道中不存在&lt;code&gt;application&lt;/code&gt;组）来执行系统通道配置更新操作。默认情况下应用程序通道配置是复制系统通道的，所以除非为了特定的capability版本而创建了不同的通道配置，否则应用程序通道的&lt;code&gt;Orderer&lt;/code&gt;组和&lt;code&gt;通道&lt;/code&gt;组与网络中其它的系统通道是一样的。&lt;/p&gt;
&lt;h3 id=&#34;orderer-system-通道-capabilities&#34;&gt;orderer system 通道 capabilities&lt;/h3&gt;
&lt;p&gt;默认情况下应用程序通道复制系统通道的配置，所以最好的操作是在跟应用程序通道前先更新系统通道的capabilities。就像&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrading_your_components.html&#34;&gt;Upgrading your components&lt;/a&gt;中所述，更新peer之前先将排序节点更新至最新版。&lt;/p&gt;
&lt;p&gt;orderer system 通道归排序服务组织管理。默认情况下，只有一个组织（在排序服务初始化节点时创建的组织），但也可以扩展多个组织（例如，有多个组织为排序服务提供节点）。&lt;/p&gt;
&lt;p&gt;在更新&lt;code&gt;Orderer&lt;/code&gt;和&lt;code&gt;通道&lt;/code&gt; capability之前，请确保在你的排序服务中的所有节点都已经升级到所需版本。如果排序节点没有升级到所需版本，它将无法处理具有该capability的配置块，并且将崩溃。类似的，如果排序服务中新增一条通道，那所有将被加入到该通道的peer节点必须至少处于&lt;code&gt;通道&lt;/code&gt;和&lt;code&gt;Application&lt;/code&gt; capabilities相近的节点版本，否则在处理配置块时这些peer节点将会崩溃。要了解更多信息，详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/capabilities_concept.html&#34;&gt;Capabilities&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;设置环境变量-2&#34;&gt;设置环境变量&lt;/h4&gt;
&lt;p&gt;你需要导入以下环境变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;CH_NAME&lt;!-- raw HTML omitted --&gt;：待更新的系统通道名称。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;CORE_PEER_LOCALMSPID&lt;!-- raw HTML omitted --&gt;：执行通道更新操作的MSP ID，排序服务组织中的MSP。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;TLS_ROOT_CA&lt;!-- raw HTML omitted --&gt;：排序节点TLS证书的绝对路径。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;CORE_PEER_MSPCONFIGPATH&lt;!-- raw HTML omitted --&gt;：标识你的组织的MSP存放的绝对路径。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;ORDERER_CONTAINER&lt;!-- raw HTML omitted --&gt;：排序节点的容器名称。访问排序服务时，你可以访问排序服务中的任意节点。你的请求会自动提交给leader节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;orderer组&#34;&gt;&lt;code&gt;Orderer&lt;/code&gt;组&lt;/h4&gt;
&lt;p&gt;关于如何拉取、传递和确定通道配置范围的命令，详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-1-pull-and-translate-the-config&#34;&gt;Step 1: Pull and translate the config&lt;/a&gt;。如果你有了&lt;code&gt;modified_config.json&lt;/code&gt;文件，那你可以使用下面的命令来新增&lt;code&gt;Orderer&lt;/code&gt;组capabilities：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;jq -s &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.[0] * {&amp;#34;通道_group&amp;#34;:{&amp;#34;groups&amp;#34;:{&amp;#34;Orderer&amp;#34;: {&amp;#34;values&amp;#34;: {&amp;#34;Capabilities&amp;#34;: .[1].orderer}}}}}&amp;#39;&lt;/span&gt; config.json ./capabilities.json &amp;gt; modified_config.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后执行步骤&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-3-re-encode-and-submit-the-config&#34;&gt;Step 3: Re-encode and submit the config&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因为你现在更新的是系统通道，系统通道修改策略只需要排序服务组织的管理员签名。&lt;/p&gt;
&lt;h4 id=&#34;通道组&#34;&gt;&lt;code&gt;通道&lt;/code&gt;组&lt;/h4&gt;
&lt;p&gt;关于如何拉取、传递和确定通道配置范围的命令，详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-1-pull-and-translate-the-config&#34;&gt;Step 1: Pull and translate the config&lt;/a&gt;。如果你有了&lt;code&gt;modified_config.json&lt;/code&gt;文件，那你可以使用下面的命令来新增&lt;code&gt;通道&lt;/code&gt;组capabilities：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;jq -s &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.[0] * {&amp;#34;通道_group&amp;#34;:{&amp;#34;values&amp;#34;: {&amp;#34;Capabilities&amp;#34;: .[1].通道}}}&amp;#39;&lt;/span&gt; config.json ./capabilities.json &amp;gt; modified_config.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后执行步骤&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-3-re-encode-and-submit-the-config&#34;&gt;Step 3: Re-encode and submit the config&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因为你现在更新的是系统通道，系统通道的修改策略只需要排序服务组织的管理员签名。在应用程序通道中，假如你没有修改默认值，通常需要同时满足&lt;code&gt;Application&lt;/code&gt;组（由peer组织的MSPs组成）和&lt;code&gt;Orderer&lt;/code&gt;组（由排序服务组织组成）的&lt;strong&gt;大多数管理员&lt;/strong&gt;策略。&lt;/p&gt;
&lt;h3 id=&#34;在已有通道上启用capabilities&#34;&gt;在已有通道上启用capabilities&lt;/h3&gt;
&lt;p&gt;现在我们来更新orderer system 通道的capabilities，我们将会更新已有通道（你想更新的）的配置。&lt;/p&gt;
&lt;p&gt;应用程序通道的配置与系统通道的非常相似。这样，我们就能复用&lt;code&gt;capabilities.json&lt;/code&gt;文件，并使用相同的命令来进行更新（只需要重新设置环境变量即可）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在更新capabilities前，请确保排序服务中的所有排序节点和通道中的所有peer节点都已升级至要求的版本，否则未升级的节点将无法处理启用了capability的配置块并引起崩溃&lt;/strong&gt;。更多信息详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/capabilities_concept.html&#34;&gt;Capabilities&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;设置环境变量-3&#34;&gt;设置环境变量&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;CH_NAME&lt;!-- raw HTML omitted --&gt;：待更新的应用程序通道名称。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;CORE_PEER_LOCALMSPID&lt;!-- raw HTML omitted --&gt;：执行通道更新操作的MSP ID，peer组织中的MSP。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;TLS_ROOT_CA&lt;!-- raw HTML omitted --&gt;：peer组织TLS证书的绝对路径。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;CORE_PEER_MSPCONFIGPATH&lt;!-- raw HTML omitted --&gt;：标识你的组织的MSP存放的绝对路径。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;ORDERER_CONTAINER&lt;!-- raw HTML omitted --&gt;：排序节点的容器名称。访问排序服务时，你可以访问排序服务中的任意节点。你的请求会自动提交给leader节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;orderer组-1&#34;&gt;&lt;code&gt;Orderer&lt;/code&gt;组&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-1-pull-and-translate-the-config&#34;&gt;Step 1: Pull and translate the config&lt;/a&gt;。如果你有了&lt;code&gt;modified_config.json&lt;/code&gt;文件，那你可以使用下面的命令来新增&lt;code&gt;Orderer&lt;/code&gt;组capabilities：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;jq -s &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.[0] * {&amp;#34;通道_group&amp;#34;:{&amp;#34;groups&amp;#34;:{&amp;#34;Orderer&amp;#34;: {&amp;#34;values&amp;#34;: {&amp;#34;Capabilities&amp;#34;: .[1].orderer}}}}}&amp;#39;&lt;/span&gt; config.json ./capabilities.json &amp;gt; modified_config.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后执行步骤&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-3-re-encode-and-submit-the-config&#34;&gt;Step 3: Re-encode and submit the config&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;该capability默认的修改策略是需要&lt;code&gt;Orderer&lt;/code&gt;组中&lt;strong&gt;大多数管理员&lt;/strong&gt;同意（即，大多数排序服务的管理员）。peer组织可以更新该capability，但这种情况下，peer组织的签名并不满足该策略。&lt;/p&gt;
&lt;h4 id=&#34;通道组-1&#34;&gt;&lt;code&gt;通道&lt;/code&gt;组&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-1-pull-and-translate-the-config&#34;&gt;Step 1: Pull and translate the config&lt;/a&gt;。如果你有了&lt;code&gt;modified_config.json&lt;/code&gt;文件，那你可以使用下面的命令来新增&lt;code&gt;通道&lt;/code&gt;组capabilities：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;jq -s &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.[0] * {&amp;#34;通道_group&amp;#34;:{&amp;#34;values&amp;#34;: {&amp;#34;Capabilities&amp;#34;: .[1].通道}}}&amp;#39;&lt;/span&gt; config.json ./capabilities.json &amp;gt; modified_config.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后执行步骤&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-3-re-encode-and-submit-the-config&#34;&gt;Step 3: Re-encode and submit the config&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;该capability默认的修改策略是需要&lt;code&gt;Application&lt;/code&gt;和&lt;code&gt;Orderer&lt;/code&gt;组&lt;strong&gt;大多数管理员&lt;/strong&gt;审核通过。也就是说，需要peer组织和排序服务组织中大多数管理员对该请求进行签名认证。&lt;/p&gt;
&lt;h4 id=&#34;application组&#34;&gt;&lt;code&gt;Application&lt;/code&gt;组&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-1-pull-and-translate-the-config&#34;&gt;Step 1: Pull and translate the config&lt;/a&gt;。如果你有了&lt;code&gt;modified_config.json&lt;/code&gt;文件，那你可以使用下面的命令来新增&lt;code&gt;通道&lt;/code&gt;组capabilities：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;jq -s &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.[0] * {&amp;#34;通道_group&amp;#34;:{&amp;#34;groups&amp;#34;:{&amp;#34;Application&amp;#34;: {&amp;#34;values&amp;#34;: {&amp;#34;Capabilities&amp;#34;: .[1].application}}}}}&amp;#39;&lt;/span&gt; config.json ./capabilities.json &amp;gt; modified_config.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后执行步骤&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-3-re-encode-and-submit-the-config&#34;&gt;Step 3: Re-encode and submit the config&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;该capability默认的修改策略是需要&lt;code&gt;Application&lt;/code&gt;组&lt;strong&gt;大多数管理员&lt;/strong&gt;审核通过。也就是说，需要peer组织中的大多数管理员进行投票。排序服务的管理员不需要参与。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这样的结果就是不要将此capability设置为不存在的版本&lt;/strong&gt;。因为排序节点既不会解析应用程序capabilities，也不会验证它，排序节点会审核通过所有的应用程序capabilities版本并将新的配置块分发给peer节点以便peer节点将其保存到账本中。这样的话，peer节点将无法处理该capability并引起崩溃。即使之后再将一个合法的capability版本配置到peer节点上，但之前的配置块仍存在于账本中，当尝试处理之前的配置块时还是会引发崩溃。&lt;/p&gt;
&lt;p&gt;这也是为什么需要&lt;code&gt;capabilities.json&lt;/code&gt;这样的文件。它可以有效防止简单的用户错误，例如，当将应用程序的apability设置为&lt;code&gt;V20&lt;/code&gt;，而不是&lt;code&gt;V2_0&lt;/code&gt;时，这会导致通道不可用且无法恢复。&lt;/p&gt;
&lt;h3 id=&#34;启用capabilities后进行验证&#34;&gt;启用capabilities后进行验证&lt;/h3&gt;
&lt;p&gt;验证capabilities是否成功启用的最好方式是在所有的通道上执行一次chaincode调用。未升级到相应版本的节点都无法解析新的capabilities，这些节点都会崩溃。在这些节点成功重启之前你需要将它们升级至相应的版本。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;启用新的chaincode-lifecycle&#34;&gt;启用新的chaincode lifecycle&lt;/h2&gt;
&lt;p&gt;用户从v1.4.x升级到v2.x后，必须编辑通道配置来启用新的lifecycle功能。这个过程涉及到相关用户必须执行的一系列&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html&#34;&gt;通道配置更新&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;要启用新的chaincode lifecycle，应用程序通道的&lt;code&gt;Channel&lt;/code&gt;和&lt;code&gt;Application&lt;/code&gt;capabilities必须更新到&lt;strong&gt;V2_0&lt;/strong&gt;，详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrade_to_newest_version.html#chaincode-lifecycle&#34;&gt;Considerations for getting to 2.0&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;总体来看，通道配置更新分三步（每个通道）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取最新的通道配置&lt;/li&gt;
&lt;li&gt;创建修改后的通道配置&lt;/li&gt;
&lt;li&gt;创建配置更新交易&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来我们使用&lt;code&gt;enable_lifecycle.json&lt;/code&gt;文件（包含我们所需要的所有通道配置更新）来更新通道配置。需要留意的是，在生成环境中，可能有多个用户发起通道更新请求。为了方便起见，我们将所有的更新都放在单个文件中呈现。&lt;/p&gt;
&lt;h3 id=&#34;创建enable_lifecyclejson文件&#34;&gt;创建&lt;code&gt;enable_lifecycle.json&lt;/code&gt;文件&lt;/h3&gt;
&lt;p&gt;除了使用&lt;code&gt;enable_lifecycle.json&lt;/code&gt;文件外，本教程还将使用&lt;code&gt;jq&lt;/code&gt;将编辑后的内容应用到文件中。修改的文件也可以手动编辑，详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#sample-channel-configuration&#34;&gt;sample channel configuration&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文展示的操作（使用JSON文件和&lt;code&gt;jq&lt;/code&gt;工具）在脚本化方面更具优势，更适合大量的通道配置更新。也是编辑通道配置的推荐操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;enable_lifecycle.json&lt;/code&gt;使用的示例，例如&lt;code&gt;org1Policies&lt;/code&gt;和&lt;code&gt;Org1ExampleCom&lt;/code&gt;，在部署时需要替换成实际值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;org1Policies&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Endorsement&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;mod_policy&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Admins&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;policy&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;: {
                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;identities&amp;#34;&lt;/span&gt;: [
                        {
                            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;principal&amp;#34;&lt;/span&gt;: {
                                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;msp_identifier&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Org1ExampleCom&amp;#34;&lt;/span&gt;,
                                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;role&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;PEER&amp;#34;&lt;/span&gt;
                            },
                            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;principal_classification&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ROLE&amp;#34;&lt;/span&gt;
                        }
                    ],
                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;rule&amp;#34;&lt;/span&gt;: {
                        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;n_out_of&amp;#34;&lt;/span&gt;: {
                            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;n&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
                            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;rules&amp;#34;&lt;/span&gt;: [
                                {
                                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;signed_by&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
                                }
                            ]
                        }
                    },
                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
                }
            },
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;
        }
    },
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;org2Policies&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Endorsement&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;mod_policy&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Admins&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;policy&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;: {
                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;identities&amp;#34;&lt;/span&gt;: [
                        {
                            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;principal&amp;#34;&lt;/span&gt;: {
                                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;msp_identifier&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Org2ExampleCom&amp;#34;&lt;/span&gt;,
                                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;role&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;PEER&amp;#34;&lt;/span&gt;
                            },
                            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;principal_classification&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ROLE&amp;#34;&lt;/span&gt;
                        }
                    ],
                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;rule&amp;#34;&lt;/span&gt;: {
                        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;n_out_of&amp;#34;&lt;/span&gt;: {
                            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;n&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
                            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;rules&amp;#34;&lt;/span&gt;: [
                                {
                                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;signed_by&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
                                }
                            ]
                        }
                    },
                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
                }
            },
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;
        }
    },
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;appPolicies&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Endorsement&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;mod_policy&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Admins&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;policy&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;,
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;: {
                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;rule&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MAJORITY&amp;#34;&lt;/span&gt;,
                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;sub_policy&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Endorsement&amp;#34;&lt;/span&gt;
                }
            },
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;
        },
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;LifecycleEndorsement&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;mod_policy&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Admins&amp;#34;&lt;/span&gt;,
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;policy&amp;#34;&lt;/span&gt;: {
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;,
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;: {
                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;rule&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MAJORITY&amp;#34;&lt;/span&gt;,
                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;sub_policy&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Endorsement&amp;#34;&lt;/span&gt;
                }
            },
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;
        }
    },
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;acls&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_lifecycle/CheckCommitReadiness&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;policy_ref&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/Channel/Application/Writers&amp;#34;&lt;/span&gt;
        },
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_lifecycle/CommitChaincodeDefinition&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;policy_ref&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/Channel/Application/Writers&amp;#34;&lt;/span&gt;
        },
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_lifecycle/QueryChaincodeDefinition&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;policy_ref&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/Channel/Application/Readers&amp;#34;&lt;/span&gt;
        },
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_lifecycle/QueryChaincodeDefinitions&amp;#34;&lt;/span&gt;: {
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;policy_ref&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/Channel/Application/Readers&amp;#34;&lt;/span&gt;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;在新的策略中，如果&lt;code&gt;NodeOUs&lt;/code&gt;启用了，&amp;ldquo;role&amp;quot;字段应该设置为&lt;code&gt;PEER&lt;/code&gt;，否则设置为&lt;code&gt;MEMBER&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;编辑通道配置&#34;&gt;编辑通道配置&lt;/h3&gt;
&lt;h4 id=&#34;系统通道更新&#34;&gt;系统通道更新&lt;/h4&gt;
&lt;p&gt;因为修改系统通道配置以启用新的lifecycle只涉及到peer组织配置中的通道配置参数，所以被编辑的peer组织都必须掉相关的通道配置更新进行签名。&lt;/p&gt;
&lt;p&gt;默认情况下，系统通道只能被系统通道的管理员编辑（排序服务组织的管理员，而非peer组织的），这意味着对联盟中peer组织的配置更新必须有系统通道管理提出，并发送给相应的peer组织进行签名。&lt;/p&gt;
&lt;p&gt;需要导入以下环境变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;CH_NAME&lt;!-- raw HTML omitted --&gt;：待更新的系统通道名称。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;CORE_PEER_LOCALMSPID&lt;!-- raw HTML omitted --&gt;：执行通道更新操作的MSP ID，排序服务组织中的MSP。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;TLS_ROOT_CA&lt;!-- raw HTML omitted --&gt;：发起系统通道更新组织的TLS证书的绝对路径。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;CORE_PEER_MSPCONFIGPATH&lt;!-- raw HTML omitted --&gt;：标识你的组织的MSP存放的绝对路径。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;ORDERER_CONTAINER&lt;!-- raw HTML omitted --&gt;：排序节点的容器名称。访问排序服务时，你可以访问排序服务中的任意节点。你的请求会自动提交给leader节点。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;ORGNAME&lt;!-- raw HTML omitted --&gt;：正在更新的组织名称。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;CONSORTIUM_NAME&lt;!-- raw HTML omitted --&gt;：正在更新的联盟名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置好环境变量之后，&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-1-pull-and-translate-the-config&#34;&gt;Step 1: Pull and translate the config&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;之后，使用下面的命令将lifecycle组织策略（&lt;code&gt;enable_lifecycle.json&lt;/code&gt;中列出的）添加到名为&lt;code&gt;modified_config.json&lt;/code&gt;文件中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;jq -s &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.[0] * {\&amp;#34;channel_group\&amp;#34;:{\&amp;#34;groups\&amp;#34;:{\&amp;#34;Consortiums\&amp;#34;:{\&amp;#34;groups\&amp;#34;: {\&amp;#34;&lt;/span&gt;$CONSORTIUM_NAME&lt;span style=&#34;color:#e6db74&#34;&gt;\&amp;#34;: {\&amp;#34;groups\&amp;#34;: {\&amp;#34;&lt;/span&gt;$ORGNAME&lt;span style=&#34;color:#e6db74&#34;&gt;\&amp;#34;: {\&amp;#34;policies\&amp;#34;: .[1].&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;ORGNAME&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Policies}}}}}}}}&amp;#34;&lt;/span&gt; config.json ./enable_lifecycle.json &amp;gt; modified_config.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-3-re-encode-and-submit-the-config&#34;&gt;Step 3: Re-encode and submit the config&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如上所述，这些更新都必须由系统通道管理员提出，并发送给相应的peer组织进行签名。&lt;/p&gt;
&lt;h4 id=&#34;应用程序通道更新&#34;&gt;应用程序通道更新&lt;/h4&gt;
&lt;h5 id=&#34;编辑peer组织&#34;&gt;编辑peer组织&lt;/h5&gt;
&lt;p&gt;我们需要对所有应用程序通道上的组织执行一组类似的编辑。&lt;/p&gt;
&lt;p&gt;跟系统通道不同，peer组织可以发起对应用程序通道的配置更新请求。如果你只是对自己的组织进行配置更新，那你不需要其它组织的签名；但如果你要更新另一个组织的配置，那你就需要这个组织的签名。&lt;/p&gt;
&lt;p&gt;需要导入以下环境变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;CH_NAME&lt;!-- raw HTML omitted --&gt;：待更新的应用程序通道名称。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;CORE_PEER_LOCALMSPID&lt;!-- raw HTML omitted --&gt;：执行通道更新操作的MSP ID，peer组织中的MSP。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;TLS_ROOT_CA&lt;!-- raw HTML omitted --&gt;：排序节点的TLS证书的绝对路径。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;CORE_PEER_MSPCONFIGPATH&lt;!-- raw HTML omitted --&gt;：标识你的组织的MSP存放的绝对路径。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;ORDERER_CONTAINER&lt;!-- raw HTML omitted --&gt;：排序节点的容器名称。访问排序服务时，你可以访问排序服务中的任意节点。你的请求会自动提交给leader节点。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;ORGNAME&lt;!-- raw HTML omitted --&gt;：正在更新的组织名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置好环境变量之后，&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-1-pull-and-translate-the-config&#34;&gt;Step 1: Pull and translate the config&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;之后，使用下面的命令将lifecycle组织策略（&lt;code&gt;enable_lifecycle.json&lt;/code&gt;中列出的）添加到名为&lt;code&gt;modified_config.json&lt;/code&gt;文件中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;jq -s &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.[0] * {\&amp;#34;channel_group\&amp;#34;:{\&amp;#34;groups\&amp;#34;:{\&amp;#34;Application\&amp;#34;: {\&amp;#34;groups\&amp;#34;: {\&amp;#34;&lt;/span&gt;$ORGNAME&lt;span style=&#34;color:#e6db74&#34;&gt;\&amp;#34;: {\&amp;#34;policies\&amp;#34;: .[1].&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;ORGNAME&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Policies}}}}}}&amp;#34;&lt;/span&gt; config.json ./enable_lifecycle.json &amp;gt; modified_config.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-3-re-encode-and-submit-the-config&#34;&gt;Step 3: Re-encode and submit the config&lt;/a&gt;。&lt;/p&gt;
&lt;h5 id=&#34;编辑应用程序通道&#34;&gt;编辑应用程序通道&lt;/h5&gt;
&lt;p&gt;在所有的应用程序通道都已经&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrade_to_newest_version.html#capabilities&#34;&gt;更新到包含V2_0capabilities&lt;/a&gt;后，新的chaincode lifecycle背书策略必须添加到所有的通道中。&lt;/p&gt;
&lt;p&gt;所需的环境变量与更新peer组织时一样。不同之处在于不需要更新配置文件中的组织配置，所以不需要设置&lt;code&gt;ORGNAME&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;设置好环境变量之后，&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-1-pull-and-translate-the-config&#34;&gt;Step 1: Pull and translate the config&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;之后，使用下面的命令将lifecycle组织策略（&lt;code&gt;enable_lifecycle.json&lt;/code&gt;中列出的）添加到名为&lt;code&gt;modified_config.json&lt;/code&gt;文件中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;jq -s &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.[0] * {&amp;#34;channel_group&amp;#34;:{&amp;#34;groups&amp;#34;:{&amp;#34;Application&amp;#34;: {&amp;#34;policies&amp;#34;: .[1].appPolicies}}}}&amp;#39;&lt;/span&gt; config.json ./enable_lifecycle.json &amp;gt; modified_config.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-3-re-encode-and-submit-the-config&#34;&gt;Step 3: Re-encode and submit the config&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;要通过通过更新请求，则必须满足配置文件中&lt;code&gt;Channel/Application&lt;/code&gt;章节配置的修改策略。默认情况下，需要该通道中的&lt;strong&gt;大多数&lt;/strong&gt;peer组织同意。&lt;/p&gt;
&lt;h5 id=&#34;编辑通道acls可选&#34;&gt;编辑通道ACLs（可选）&lt;/h5&gt;
&lt;p&gt;下面的&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/access_control.html&#34;&gt;访问控制列表（ACL）&lt;/a&gt;是&lt;code&gt;enable_lifecycle.json&lt;/code&gt;文件中的默认值，可根据你的使用场景进行选择：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;acls&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;:&lt;/span&gt; {
 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_lifecycle/CheckCommitReadiness&amp;#34;&lt;/span&gt;: {
   &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;policy_ref&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/Channel/Application/Writers&amp;#34;&lt;/span&gt;
 },
 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_lifecycle/CommitChaincodeDefinition&amp;#34;&lt;/span&gt;: {
   &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;policy_ref&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/Channel/Application/Writers&amp;#34;&lt;/span&gt;
 },
 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_lifecycle/QueryChaincodeDefinition&amp;#34;&lt;/span&gt;: {
   &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;policy_ref&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/Channel/Application/Readers&amp;#34;&lt;/span&gt;
 },
 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;_lifecycle/QueryChaincodeDefinitions&amp;#34;&lt;/span&gt;: {
   &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;policy_ref&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/Channel/Application/Readers&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以使用前面编辑应用程序通道时使用的环境变量。&lt;/p&gt;
&lt;p&gt;设置好环境变量之后，&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-1-pull-and-translate-the-config&#34;&gt;Step 1: Pull and translate the config&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;之后，使用下面的命令将lifecycle组织策略（&lt;code&gt;enable_lifecycle.json&lt;/code&gt;中列出的）添加到名为&lt;code&gt;modified_config.json&lt;/code&gt;文件中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;jq -s &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.[0] * {&amp;#34;channel_group&amp;#34;:{&amp;#34;groups&amp;#34;:{&amp;#34;Application&amp;#34;: {&amp;#34;values&amp;#34;: {&amp;#34;ACLs&amp;#34;: {&amp;#34;value&amp;#34;: {&amp;#34;acls&amp;#34;: .[1].acls}}}}}}}&amp;#39;&lt;/span&gt; config.json ./enable_lifecycle.json &amp;gt; modified_config.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/config_update.html#step-3-re-encode-and-submit-the-config&#34;&gt;Step 3: Re-encode and submit the config&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;要通过通过更新请求，则必须满足配置文件中&lt;code&gt;Channel/Application&lt;/code&gt;章节配置的修改策略。默认情况下，需要该通道中的&lt;strong&gt;大多数&lt;/strong&gt;peer组织同意。&lt;/p&gt;
&lt;h3 id=&#34;在coreyaml中启用新的lifecycle&#34;&gt;在&lt;code&gt;core.yaml&lt;/code&gt;中启用新的lifecycle&lt;/h3&gt;
&lt;p&gt;如果你是按照&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrading_your_components.html#overview&#34;&gt;推荐操作&lt;/a&gt;，使用&lt;code&gt;diff&lt;/code&gt;之类的工具比较新旧&lt;code&gt;core.yaml&lt;/code&gt;，那你就不必添加&lt;code&gt;_lifecycle: enable&lt;/code&gt;来启用系统chaincode，因为它在新版&lt;code&gt;core.yaml&lt;/code&gt;的&lt;code&gt;chaincode/system&lt;/code&gt;下。&lt;/p&gt;
&lt;p&gt;如果你是直接更新原有的YAML文件，那就必须添加&lt;code&gt;_lifecycle: enable&lt;/code&gt;来启用系统chaincode。&lt;/p&gt;
&lt;p&gt;关于节点升级的信息，详见&lt;a href=&#34;https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrading_your_components.html&#34;&gt;Upgrading your components&lt;/a&gt;。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Fabric网络升级示例</title>
      <link>https://mengbin92.github.io/post/fabric/example/</link>
      <pubDate>Sun, 20 Feb 2022 16:31:50 +0800</pubDate>
      
      <guid>https://mengbin92.github.io/post/fabric/example/</guid>
      
        <description>&lt;h1 id=&#34;fabric-v14x升级至v220&#34;&gt;Fabric v1.4.x升级至v2.2.0&lt;/h1&gt;
&lt;p&gt;以&lt;code&gt;fabric-samples v1.4.8&lt;/code&gt;为例，将v1.4.8升级至v2.2.0。注意，所有节点以滚动的方式进行升级，这样可以保证即使单个节点数据备份过程出错也不会影响整个网络的运行。先升级orderer节点，再升级peer节点。&lt;/p&gt;
&lt;h2 id=&#34;前期准备&#34;&gt;前期准备&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;v1.4.xFabric网络&lt;/li&gt;
&lt;li&gt;v2.2.0 docker镜像：
&lt;ol&gt;
&lt;li&gt;hyperledger/fabric-ca&lt;/li&gt;
&lt;li&gt;hyperledger/fabric-tools&lt;/li&gt;
&lt;li&gt;hyperledger/fabric-peer&lt;/li&gt;
&lt;li&gt;hyperledger/fabric-orderer&lt;/li&gt;
&lt;li&gt;hyperledger/fabric-ccenv&lt;/li&gt;
&lt;li&gt;hyperledger/fabric-baseos&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;升级orderer节点&#34;&gt;升级orderer节点&lt;/h2&gt;
&lt;p&gt;升级每个orderer时，都需要执行以下操作。&lt;/p&gt;
&lt;h3 id=&#34;1配置orderer容器中的环境变量&#34;&gt;1、配置orderer容器中的环境变量&lt;/h3&gt;
&lt;p&gt;方便起见，orderer容器运行时需要的环境变量可以记录在文件中，具体内容如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FABRIC_LOGGING_SPEC=INFO
FABRIC_CFG_PATH=/etc/hyperledger/fabric
ORDERER_GENERAL_LISTENADDRESS=0.0.0.0
ORDERER_GENERAL_GENESISMETHOD=file
ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block
ORDERER_GENERAL_LOCALMSPID=OrdererMSP
ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp
# enabled TLS
ORDERER_GENERAL_TLS_ENABLED=true
ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key
ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt
ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]
ORDERER_KAFKA_TOPIC_REPLICATIONFACTOR=1
ORDERER_KAFKA_VERBOSE=true
ORDERER_GENERAL_CLUSTER_CLIENTCERTIFICATE=/var/hyperledger/orderer/tls/server.crt
ORDERER_GENERAL_CLUSTER_CLIENTPRIVATEKEY=/var/hyperledger/orderer/tls/server.key
ORDERER_GENERAL_CLUSTER_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;2设置升级时的环境变量&#34;&gt;2、设置升级时的环境变量&lt;/h3&gt;
&lt;p&gt;在升级排序节点前导入以下环境变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;ORDERER_CONTAINER&lt;!-- raw HTML omitted --&gt;：排序节点的容器名称。注意，每个节点升级时你都样设置一遍。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;LEDGERS_BACKUP&lt;!-- raw HTML omitted --&gt;：存放备份数据的路径。就如下面的示例中，每个节点都有它自己的子目录来存放它的账本。目录如果不存在的话，你需要手动创建。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;IMAGE_TAG&lt;!-- raw HTML omitted --&gt;：你期望升级到的Fabric版本，例如v2.0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;export ORDERER_CONTAINER&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;orderer.example.com
export LEDGERS_BACKUP&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/root/upgrade/backup
export IMAGE_TAG&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;2.2.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;3升级&#34;&gt;3、升级&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;export FABRIC_SAMPLES&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/root/go/src/github.com/hyperledger/fabric-samples/
&lt;span style=&#34;color:#75715e&#34;&gt;# 停止容器&lt;/span&gt;
docker stop $ORDERER_CONTAINER
&lt;span style=&#34;color:#75715e&#34;&gt;# 备份账本和MSPs&lt;/span&gt;
docker cp $ORDERER_CONTAINER:/var/hyperledger/production/orderer/ $LEDGERS_BACKUP/$ORDERER_CONTAINER
&lt;span style=&#34;color:#75715e&#34;&gt;# 删除容器&lt;/span&gt;
docker rm -f $ORDERER_CONTAINER
&lt;span style=&#34;color:#75715e&#34;&gt;# 升级容器&lt;/span&gt;
docker run -d -v $LEDGERS_BACKUP/$ORDERER_CONTAINER/:/var/hyperledger/production/orderer/ -v $FABRIC_SAMPLES/first-network/channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block -v $FABRIC_SAMPLES/first-network/crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/msp:/var/hyperledger/orderer/msp -v $FABRIC_SAMPLES/first-network/crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/:/var/hyperledger/orderer/tls  --env-file ./env_order.list  --net net_byfn --name $ORDERER_CONTAINER  -p 7050:7050 hyperledger/fabric-orderer:$IMAGE_TAG orderer  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;升级peer节点&#34;&gt;升级peer节点&lt;/h2&gt;
&lt;p&gt;以peer0org1节点为例，以下操作每个peer节点都需要执行。&lt;/p&gt;
&lt;h3 id=&#34;1配置peer运行时的环境变量&#34;&gt;1、配置peer运行时的环境变量&lt;/h3&gt;
&lt;p&gt;方便起见，peer容器运行时需要的环境变量可以记录在文件中，具体内容如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CORE_PEER_LOCALMSPID=Org1MSP
CORE_PEER_GOSSIP_USELEADERELECTION=true
CORE_PEER_ID=peer0.org1.example.com
CORE_PEER_ADDRESS=peer0.org1.example.com:7051
FABRIC_CFG_PATH=/etc/hyperledger/fabric
CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=net_byfn
CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:7051
CORE_PEER_PROFILE_ENABLED=true
CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
CORE_PEER_LISTENADDRESS=0.0.0.0:7051
CORE_PEER_GOSSIP_ORGLEADER=false
CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/tls/server.crt
CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:7052
CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/tls/server.key
CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/tls/ca.crt
CORE_PEER_GOSSIP_BOOTSTRAP=peer1.org1.example.com:8051
CORE_PEER_TLS_ENABLED=true
FABRIC_LOGGING_SPEC=INFO
CORE_PEER_CHAINCODEADDRESS=peer0.org1.example.com:7052
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;2设置升级时的环境变量-1&#34;&gt;2、设置升级时的环境变量&lt;/h3&gt;
&lt;p&gt;在升级peer节点前导入以下环境变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;PEER_CONTAINER&lt;!-- raw HTML omitted --&gt;：peer节点的容器名称。注意，每个节点升级时你都样设置一遍。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;LEDGERS_BACKUP&lt;!-- raw HTML omitted --&gt;：存放备份数据的路径。就如下面的示例中，每个节点都有它自己的子目录来存放它的账本。目录如果不存在的话，你需要手动创建。&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;IMAGE_TAG&lt;!-- raw HTML omitted --&gt;：你期望升级到的Fabric版本，例如v2.0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;export PEER_CONTAINER&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;peer0.org1.example.com
export LEDGERS_BACKUP&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/root/upgrade/backup
export IMAGE_TAG&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;2.2.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;3升级-1&#34;&gt;3、升级&lt;/h3&gt;
&lt;p&gt;在升级的你的peers节点之前，你还需要额外进行一步操作，那就是升级peer数据库。所有peers节点的数据库（不仅包括状态数据库，还包括历史数据库和peer节点的其它内部数据库）都必须使用v2.x的数据格式进行重建，这是升级到v2.x版本的一部分。要出发重建操作，在peers节点启动前需要删除数据库。接下来介绍如何使用&lt;code&gt;peer node upgrade-dbs&lt;/code&gt;命令来删除本地数据库并为升级做好准备，这样在启动v2.xpeers节点的第一时间，所有的数据库都会被重建。如果你使用CouchDB作为状态数据库，v2.2的peers已经支持自动删除CouchDB了。要启用该支持，需要你配置peer使用CouchDB，且在执行&lt;code&gt;upgrade-dbs&lt;/code&gt;命令前启动CouchDB。在v2.0和v2.1中，peer并不支持自动删除CouchDB数据库，你需要自己手动删除。&lt;/p&gt;
&lt;p&gt;peer节点会在启动之后立即使用v2.x数据格式重建数据库。由于重建数据库可能是一个漫长的过程（这取决于你的数据库大小，可能长达数小时），所以需要实时检查peer节点的日志来确认重建的进度。每隔1000个区块，你会看到如下信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;[lockbasedtxmgr] CommitLostBlock -&amp;gt; INFO 041 Recommitting block [1000] to state database&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;表示数据库还在重建中。&lt;/p&gt;
&lt;p&gt;如果升级过程中没有删除数据库，在peer节点启动时会返回错误信息：&lt;strong&gt;peer节点使用的是老旧的数据格式，必须使用&lt;code&gt;peer node upgrade-dbs&lt;/code&gt;命令删除上述数据库（如果使用CouchDB作为状态数据库，则需要手动删除）&lt;/strong&gt;。处理完成后重启节点即可。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 停止容器&lt;/span&gt;
docker stop $PEER_CONTAINER
&lt;span style=&#34;color:#75715e&#34;&gt;# 备份账本和MSPs&lt;/span&gt;
docker cp $PEER_CONTAINER:/var/hyperledger/production $LEDGERS_BACKUP/$PEER_CONTAINER
&lt;span style=&#34;color:#75715e&#34;&gt;# 删除CC容器&lt;/span&gt;
CC_CONTAINERS&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;docker ps | grep dev-$PEER_CONTAINER | awk &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt; -n &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$CC_CONTAINERS&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; ; &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt; docker rm -f $CC_CONTAINERS ; &lt;span style=&#34;color:#66d9ef&#34;&gt;fi&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# 删除CC镜像&lt;/span&gt;
CC_IMAGES&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;docker images | grep dev-$PEER | awk &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt; -n &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$CC_IMAGES&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; ; &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt; docker rmi -f $CC_IMAGES ; &lt;span style=&#34;color:#66d9ef&#34;&gt;fi&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# 删除peer容器&lt;/span&gt;
docker rm -f $PEER_CONTAINER
&lt;span style=&#34;color:#75715e&#34;&gt;# 升级peer节点数据库&lt;/span&gt;
docker run --rm -v $LEDGERS_BACKUP/$PEER_CONTAINER:/var/hyperledger/production/ -v /var/run/:/host/var/run/ -v $FABRIC_SAMPLES/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/msp -v $FABRIC_SAMPLES/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/tls -p 7051:7051 --env-file env_peer.list --net net_byfn --name $PEER_CONTAINER  hyperledger/fabric-peer:$IMAGE_TAG peer node upgrade-dbs
&lt;span style=&#34;color:#75715e&#34;&gt;# 升级peer节点&lt;/span&gt;
docker run -d -v $LEDGERS_BACKUP/$PEER_CONTAINER:/var/hyperledger/production/ -v /var/run/:/host/var/run/ -v $FABRIC_SAMPLES/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/msp -v $FABRIC_SAMPLES/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/tls -p 7051:7051 --env-file env_peer.list --net net_byfn --name $PEER_CONTAINER  hyperledger/fabric-peer:$IMAGE_TAG peer node start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      
    </item>
    
  </channel>
</rss>
